
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/action.go (100.0%)</option>
				
				<option value="file1">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/cell.go (100.0%)</option>
				
				<option value="file2">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/connection.go (76.2%)</option>
				
				<option value="file3">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/connection_json.go (55.6%)</option>
				
				<option value="file4">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/connection_mutex.go (81.2%)</option>
				
				<option value="file5">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/field.go (78.1%)</option>
				
				<option value="file6">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/field_mutex.go (81.1%)</option>
				
				<option value="file7">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/lobby.go (32.3%)</option>
				
				<option value="file8">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/lobby_handle.go (42.3%)</option>
				
				<option value="file9">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/lobby_history.go (0.0%)</option>
				
				<option value="file10">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/lobby_json.go (18.2%)</option>
				
				<option value="file11">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/lobby_mutex.go (21.4%)</option>
				
				<option value="file12">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/lobby_players.go (12.8%)</option>
				
				<option value="file13">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/lobby_request.go (66.7%)</option>
				
				<option value="file14">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/lobby_room.go (0.0%)</option>
				
				<option value="file15">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/lobby_send.go (18.7%)</option>
				
				<option value="file16">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/message.go (0.0%)</option>
				
				<option value="file17">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/player.go (28.6%)</option>
				
				<option value="file18">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/room.go (10.9%)</option>
				
				<option value="file19">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/room_database.go (0.0%)</option>
				
				<option value="file20">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/room_game.go (0.0%)</option>
				
				<option value="file21">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/room_handle.go (0.0%)</option>
				
				<option value="file22">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/room_json.go (0.0%)</option>
				
				<option value="file23">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/room_mutex.go (0.0%)</option>
				
				<option value="file24">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/room_players.go (0.0%)</option>
				
				<option value="file25">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/room_send.go (0.0%)</option>
				
				<option value="file26">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/send.go (35.7%)</option>
				
				<option value="file27">github.com/go-park-mail-ru/2019_1_Escapade/internal/game/slice.go (12.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package game

import "time"

// Player actions
const (
        ActionError = iota - 1
        ActionNo
        ActionConnectAsPlayer
        ActionConnectAsObserver
        ActionReconnect
        ActionDisconnect
        ActionStop
        ActionContinue
        ActionExplode
        ActionWin
        ActionLose
        ActionFlagLost
        ActionGetPoints
        ActionFlagSet
        ActionGiveUp
        ActionBackToLobby
        ActionTimeOver
)

// PlayerAction combine player and his action
type PlayerAction struct {
        Player int       `json:"player"`
        Action int       `json:"action"`
        Time   time.Time `json:"-"`
}

// NewPlayerAction return new instance of PlayerAction
func NewPlayerAction(player int, action int) *PlayerAction <span class="cov8" title="1">{
        pa := &amp;PlayerAction{
                Player: player,
                Action: action,
                Time:   time.Now(),
        }
        return pa
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package game

import "time"

// Cell send to user one cell
type Cell struct {
        X        int       `json:"x"`
        Y        int       `json:"y"`
        Value    int       `json:"value"`
        PlayerID int       `json:"playerID"`
        Time     time.Time `json:"-"`
}

// NewCell create new instance of cell
func NewCell(x int, y int, v int, ID int) *Cell <span class="cov8" title="1">{
        cell := &amp;Cell{
                X:        x,
                Y:        y,
                Value:    v,
                PlayerID: ID,
                Time:     time.Now(),
        }
        return cell
}</span>

// Cell type
const (
        CellMine   = iota + 9 // +9, cause &lt;9 - amount of mines around
        CellOpened            // for empty cells
        CellFlag
        CellFlagTaken
        CellIncrement // for id
)
</pre>
		
		<pre class="file" id="file2" style="display: none">package game

import (
        "encoding/json"

        "github.com/go-park-mail-ru/2019_1_Escapade/internal/config"
        "github.com/go-park-mail-ru/2019_1_Escapade/internal/models"
        "github.com/go-park-mail-ru/2019_1_Escapade/internal/utils"

        "fmt"
        "sync"
        "time"

        "context"

        "github.com/gorilla/websocket"
)

// NewConnection creates a new connection
func NewConnection(ws *websocket.Conn, user *models.UserPublicInfo, lobby *Lobby) *Connection <span class="cov8" title="1">{
        if ws == nil || user == nil || lobby == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">context, cancel := context.WithCancel(lobby.context)

        return &amp;Connection{
                wGroup: &amp;sync.WaitGroup{},

                doneM: &amp;sync.RWMutex{},
                _done: false,

                roomM: &amp;sync.RWMutex{},
                _room: nil,

                disconnectedM: &amp;sync.RWMutex{},
                _Disconnected: false,

                bothM: &amp;sync.RWMutex{},
                _both: false,

                indexM: &amp;sync.RWMutex{},
                _Index: -1,

                User: user,

                ws:    ws,
                lobby: lobby,

                context: context,
                cancel:  cancel,

                send:      make(chan []byte),
                actionSem: make(chan struct{}, 1),
        }</span>
}

// PushToRoom set field 'room' to real room
func (conn *Connection) PushToRoom(room *Room) <span class="cov8" title="1">{
        if conn.done() </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">conn.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                conn.wGroup.Done()
        }</span>()

        <span class="cov8" title="1">conn.setRoom(room)</span>
}

// PushToLobby set field 'room' to nil
func (conn *Connection) PushToLobby() <span class="cov8" title="1">{
        if conn.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">conn.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                conn.wGroup.Done()
        }</span>()

        <span class="cov8" title="1">conn.setRoom(nil)
        conn.setBoth(false)</span>
}

// IsConnected check player isnt disconnected
func (conn *Connection) IsConnected() bool <span class="cov8" title="1">{
        if conn.done() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">conn.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                conn.wGroup.Done()
        }</span>()
        <span class="cov8" title="1">return conn.Disconnected() == false</span>
}

// dirty make connection dirty. it make connection ID
// -1 and when connection try to leave lobby, lobby will not
// delete this connections from list, cause it will not find
// anybody with such id
func (conn *Connection) Dirty() <span class="cov8" title="1">{
        if conn.done() </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">conn.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                conn.wGroup.Done()
        }</span>()
        <span class="cov8" title="1">conn.User.ID = -1</span>
}

// Kill call context.CancFunc, that finish goroutines of
// writer and reader and free connection memory
func (conn *Connection) Kill(message string, makeDirty bool) <span class="cov8" title="1">{
        if conn.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">conn.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                conn.wGroup.Done()
        }</span>()

        <span class="cov8" title="1">fmt.Println("SendInformation")
        conn.SendInformation(message)
        if makeDirty </span><span class="cov0" title="0">{
                conn.Dirty()
        }</span>
        <span class="cov8" title="1">fmt.Println("setDisconnected")
        conn.setDisconnected()
        fmt.Println("cancel")
        conn.cancel()
        fmt.Println("done")</span>
}

// Free free memory, if flag disconnect true then connection and player will not become nil
func (conn *Connection) Free() <span class="cov0" title="0">{

        if conn.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">conn.setDone()

        conn.wGroup.Wait()

        // dont delete. conn = nil make pointer nil, but other pointers
        // arent nil. If conn.disconnected = true it is mean that all
        // resources are cleared, but pointer alive, so we only make pointer = nil
        if conn.lobby == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">conn.setDisconnected()

        conn.ws.Close()
        close(conn.send)
        close(conn.actionSem)
        // dont delete. conn = nil make pointer nil, but other pointers
        // arent nil and we make 'conn.disconnected = true' for them

        conn.lobby = nil
        conn.setRoom(nil)

        fmt.Println("conn free memory")</span>
}

// InRoom check is player in room
func (conn *Connection) InRoom() bool <span class="cov8" title="1">{
        if conn.done() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">conn.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                conn.wGroup.Done()
        }</span>()
        <span class="cov8" title="1">return conn.Room() != nil</span>
}

// Launch run the writer and reader goroutines and wait them to free memory
func (conn *Connection) Launch(ws config.WebSocketSettings) <span class="cov8" title="1">{

        // dont place there conn.wGroup.Add(1)
        if conn.lobby == nil || conn.lobby.context == nil </span><span class="cov0" title="0">{
                fmt.Println("lobby nil or hasnt context!")
                return
        }</span>

        <span class="cov8" title="1">all := &amp;sync.WaitGroup{}

        fmt.Println("JoinConn!")

        all.Add(1)
        go conn.WriteConn(conn.context, ws, all)
        all.Add(1)
        go conn.ReadConn(conn.context, ws, all)

        conn.lobby.JoinConn(conn)
        fmt.Println("Wait!")
        all.Wait()
        fmt.Println("conn finished")
        conn.lobby.Leave(conn, "finished")
        conn.Free()</span>
}

// ReadConn connection goroutine to read messages from websockets
func (conn *Connection) ReadConn(parent context.Context, wsc config.WebSocketSettings, wg *sync.WaitGroup) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                wg.Done()
        }</span>()
        <span class="cov8" title="1">if conn.done() </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">conn.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                conn.wGroup.Done()
                utils.CatchPanic("connection.go WriteConn()")
        }</span>()

        <span class="cov8" title="1">conn.ws.SetReadLimit(wsc.MaxMessageSize)
        conn.ws.SetReadDeadline(time.Now().Add(wsc.PongWait))
        conn.ws.SetPongHandler(
                func(string) error </span><span class="cov0" title="0">{
                        conn.ws.SetReadDeadline(time.Now().Add(wsc.PongWait))
                        return nil
                }</span>)
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-parent.Done():<span class="cov0" title="0">
                        fmt.Println("ReadConn done catched")
                        return</span>
                default:<span class="cov8" title="1">
                        _, message, err := conn.ws.ReadMessage()
                        if err != nil </span><span class="cov8" title="1">{
                                if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway) </span><span class="cov8" title="1">{
                                        fmt.Println("IsUnexpectedCloseError:" + err.Error())
                                }</span> else<span class="cov8" title="1"> {
                                        fmt.Println("expected error:" + err.Error())
                                }</span>
                                //conn.Kill("Client websocket died", false)
                                <span class="cov8" title="1">return</span>
                        }
                        <span class="cov0" title="0">conn.debug("read from conn")
                        conn.lobby.chanBroadcast &lt;- &amp;Request{
                                Connection: conn,
                                Message:    message,
                        }</span>
                }
        }
}

// write writes a message with the given message type and payload.
func (conn *Connection) write(mt int, payload []byte, wsc config.WebSocketSettings) error <span class="cov8" title="1">{
        conn.ws.SetWriteDeadline(time.Now().Add(wsc.WriteWait))
        return conn.ws.WriteMessage(mt, payload)
}</span>

// WriteConn connection goroutine to write messages to websockets
// dont put conn.debug here
func (conn *Connection) WriteConn(parent context.Context, wsc config.WebSocketSettings, wg *sync.WaitGroup) <span class="cov8" title="1">{
        defer wg.Done()

        if conn.done() </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">conn.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                conn.wGroup.Done()
                utils.CatchPanic("connection.go WriteConn()")
        }</span>()

        <span class="cov8" title="1">ticker := time.NewTicker(wsc.PingPeriod)
        defer ticker.Stop()

        writeSem := make(chan struct{}, 1)
        defer close(writeSem)

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-parent.Done():<span class="cov8" title="1">
                        fmt.Println("WriteConn done catched")
                        return</span>
                case message, ok := &lt;-conn.send:<span class="cov8" title="1">
                        writeSem &lt;- struct{}{}
                        defer func() </span><span class="cov8" title="1">{ &lt;-writeSem }</span>()
                        <span class="cov8" title="1">fmt.Println("saw!")
                        //fmt.Println("server wrote:", string(message))
                        if !ok </span><span class="cov0" title="0">{
                                fmt.Println("errrrrr!")
                                conn.write(websocket.CloseMessage, []byte{}, wsc)
                                return
                        }</span>
                        <span class="cov8" title="1">fmt.Println("send something")

                        conn.ws.SetWriteDeadline(time.Now().Add(wsc.WriteWait))
                        w, err := conn.ws.NextWriter(websocket.TextMessage)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">w.Write(message)

                        if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        if err := conn.write(websocket.PingMessage, []byte{}, wsc); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// SendInformation send info
func (conn *Connection) SendInformation(value interface{}) <span class="cov8" title="1">{
        if conn.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">conn.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                conn.wGroup.Done()
        }</span>()

        <span class="cov8" title="1">if !conn.Disconnected() </span><span class="cov8" title="1">{
                var (
                        bytes []byte
                        err   error
                )

                bytes, err = json.Marshal(value)

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("cant send information", err.Error())
                }</span> else<span class="cov8" title="1"> {
                        fmt.Println("server wrote to", conn.ID(), ":", string(bytes))
                        conn.send &lt;- bytes
                        fmt.Println("move!")
                }</span>
        }
}

// sendGroupInformation send info with WaitGroup
func (conn *Connection) sendGroupInformation(value interface{}, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                wg.Done()
                utils.CatchPanic("connection.go sendGroupInformation()")
        }</span>()
        <span class="cov0" title="0">conn.SendInformation(value)</span>
}

// ID return players id
func (conn *Connection) ID() int <span class="cov8" title="1">{
        if conn.done() </span><span class="cov0" title="0">{
                return conn.User.ID
        }</span>
        <span class="cov8" title="1">conn.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                conn.wGroup.Done()
        }</span>()
        <span class="cov8" title="1">if conn.User == nil </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov8" title="1">return conn.User.ID</span>
}

// debug print devug information to console and websocket
func (conn *Connection) debug(message string) <span class="cov8" title="1">{
        fmt.Println("Connection #", conn.ID(), "-", message)
        conn.SendInformation(message)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package game

import (
        "context"
        "encoding/json"
        "sync"

        "github.com/go-park-mail-ru/2019_1_Escapade/internal/models"
        "github.com/gorilla/websocket"
)

// Connection is a websocket of a player, that belongs to room
type Connection struct {
        wGroup *sync.WaitGroup

        doneM *sync.RWMutex
        _done bool

        roomM *sync.RWMutex
        _room *Room

        disconnectedM *sync.RWMutex
        _Disconnected bool

        bothM *sync.RWMutex
        _both bool

        indexM *sync.RWMutex
        _Index int

        User *models.UserPublicInfo

        ws    *websocket.Conn
        lobby *Lobby

        context context.Context
        cancel  context.CancelFunc

        actionSem chan struct{}

        send chan []byte
}

type ConnectionJSON struct {
        Disconnected bool `json:"disconnected"`
        Index        int  `json:"index"`

        User *models.UserPublicInfo `json:"user,omitempty"`
}

func (conn *Connection) JSON() ConnectionJSON <span class="cov8" title="1">{
        return ConnectionJSON{
                Disconnected: conn.Disconnected(),
                Index:        conn.Index(),
                User:         conn.User,
        }
}</span>

func (conn *Connection) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(conn.JSON())
}</span>

func (conn *Connection) UnmarshalJSON(b []byte) error <span class="cov8" title="1">{
        temp := &amp;ConnectionJSON{}

        if err := json.Unmarshal(b, &amp;temp); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">conn._Disconnected = temp.Disconnected
        conn._Index = temp.Index
        conn.User = temp.User

        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package game

import (
        re "github.com/go-park-mail-ru/2019_1_Escapade/internal/return_errors"
)

// setMatrixValue set a value to matrix
func (conn *Connection) setDone() <span class="cov8" title="1">{
        conn.doneM.Lock()
        conn._done = true
        conn.doneM.Unlock()
}</span>

// getMatrixValue get a value from matrix
func (conn *Connection) done() bool <span class="cov8" title="1">{
        conn.doneM.RLock()
        v := conn._done
        conn.doneM.RUnlock()
        return v
}</span>

// getMatrixValue get a value from matrix
func (conn *Connection) Disconnected() bool <span class="cov8" title="1">{
        if conn.done() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">conn.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                conn.wGroup.Done()
        }</span>()

        <span class="cov8" title="1">conn.disconnectedM.RLock()
        v := conn._Disconnected
        conn.disconnectedM.RUnlock()
        return v</span>
}

// getMatrixValue get a value from matrix
func (conn *Connection) setDisconnected() <span class="cov8" title="1">{
        conn.disconnectedM.Lock()
        conn._Disconnected = true
        conn.disconnectedM.Unlock()
}</span>

// getMatrixValue get a value from matrix
func (conn *Connection) Room() *Room <span class="cov8" title="1">{
        if conn.done() </span><span class="cov8" title="1">{
                return conn._room
        }</span>
        <span class="cov8" title="1">conn.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                conn.wGroup.Done()
        }</span>()

        <span class="cov8" title="1">conn.roomM.RLock()
        v := conn._room
        conn.roomM.RUnlock()
        return v</span>
}

// getMatrixValue get a value from matrix
func (conn *Connection) RoomID() string <span class="cov8" title="1">{
        if conn.done() </span><span class="cov8" title="1">{
                return re.ErrorConnectionDone().Error()
        }</span>
        <span class="cov0" title="0">conn.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                conn.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">conn.roomM.RLock()
        v := conn._room.ID
        conn.roomM.RUnlock()
        return v</span>
}

// getMatrixValue get a value from matrix
func (conn *Connection) Both() bool <span class="cov8" title="1">{
        if conn.done() </span><span class="cov8" title="1">{
                return conn._both
        }</span>
        <span class="cov8" title="1">conn.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                conn.wGroup.Done()
        }</span>()

        <span class="cov8" title="1">conn.bothM.RLock()
        v := conn._both
        conn.bothM.RUnlock()
        return v</span>
}

// getMatrixValue get a value from matrix
func (conn *Connection) Index() int <span class="cov8" title="1">{
        if conn.done() </span><span class="cov8" title="1">{
                return conn._Index
        }</span>
        <span class="cov8" title="1">conn.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                conn.wGroup.Done()
        }</span>()

        <span class="cov8" title="1">conn.indexM.RLock()
        v := conn._Index
        conn.indexM.RUnlock()
        return v</span>
}

func (conn *Connection) SetIndex(value int) <span class="cov8" title="1">{
        if conn.done() </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">conn.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                conn.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">conn.indexM.Lock()
        conn._Index = value
        conn.indexM.Unlock()</span>
}

// setMatrixValue set a value to matrix
func (conn *Connection) setRoom(room *Room) <span class="cov8" title="1">{
        conn.roomM.Lock()
        conn._room = room
        conn.roomM.Unlock()
}</span>

// setMatrixValue set a value to matrix
func (conn *Connection) setBoth(both bool) <span class="cov8" title="1">{
        conn.bothM.Lock()
        conn._both = both
        conn.bothM.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package game

import (
        "sync"

        "github.com/go-park-mail-ru/2019_1_Escapade/internal/models"

        "fmt"
        "math/rand"
        "time"
)

// Field send to user, if he disconnect and 'forgot' everything
// about map or it is his first connect
type Field struct {
        wGroup *sync.WaitGroup

        doneM *sync.RWMutex
        done  bool

        matrixM *sync.RWMutex
        Matrix  [][]int `json:"-"`

        historyM *sync.Mutex
        History  []Cell `json:"history"`
        Width    int    `json:"width"`
        Height   int    `json:"height"`

        cellsLeftM *sync.RWMutex
        CellsLeft  int `json:"-"`
        Mines      int `json:"mines"`
}

// NewField create new instance of field
func NewField(rs *models.RoomSettings) *Field <span class="cov8" title="1">{
        matrix := generate(rs)
        field := &amp;Field{
                wGroup: &amp;sync.WaitGroup{},

                doneM: &amp;sync.RWMutex{},
                done:  false,

                matrixM: &amp;sync.RWMutex{},
                Matrix:  matrix,

                historyM: &amp;sync.Mutex{},
                History:  make([]Cell, 0, rs.Width*rs.Height),
                Width:    rs.Width,
                Height:   rs.Height,
                Mines:    rs.Mines,

                cellsLeftM: &amp;sync.RWMutex{},
                CellsLeft:  rs.Width*rs.Height - rs.Mines - rs.Players,
        }
        return field
}</span>

// place wg.add() and wg.Done() to all import functions

// Free clear matrix and history
func (field *Field) Free() <span class="cov8" title="1">{

        field.setDone()

        field.wGroup.Wait()
        for i := 0; i &lt; len(field.Matrix); i++ </span><span class="cov8" title="1">{
                field.Matrix[i] = nil
        }</span>
        <span class="cov8" title="1">go field.matrixFree()
        go field.historyFree()</span>
}

// SameAs compare two fields
func (field *Field) SameAs(another *Field) bool <span class="cov8" title="1">{
        field.wGroup.Add(1)
        defer field.wGroup.Done()

        left1 := field.getCellsLeft()
        left2 := field.getCellsLeft()

        compare := field.Width == another.Width &amp;&amp;
                field.Height == another.Height &amp;&amp;
                left1 == left2

        return compare
}</span>

// OpenEverything open all cells
func (field *Field) OpenEverything(cells *[]Cell) <span class="cov8" title="1">{
        if field.getDone() </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">field.wGroup.Add(1)
        defer field.wGroup.Done()

        for i := 0; i &lt; field.Height; i++ </span><span class="cov8" title="1">{
                for j := 0; j &lt; field.Width; j++ </span><span class="cov8" title="1">{
                        v := field.getMatrixValue(i, j)
                        if v != CellOpened </span><span class="cov8" title="1">{
                                cell := NewCell(i, j, v, 0)
                                field.saveCell(cell, cells)
                                field.setCellOpen(i, j)
                        }</span>
                }
        }
}

// openCellArea open cell area, if there is no mines around
// in this cell
func (field *Field) openCellArea(x, y, ID int, cells *[]Cell) <span class="cov8" title="1">{
        if field.areCoordinatesRight(x, y) </span><span class="cov8" title="1">{
                v := field.getMatrixValue(x, y)
                fmt.Printf("openCellArea Cell(%d/%d)=%d", x, y, v)

                if v &lt; CellMine </span><span class="cov8" title="1">{
                        cell := NewCell(x, y, v, ID)
                        field.saveCell(cell, cells)
                        field.decrementCellsLeft()
                        field.setCellOpen(x, y)
                }</span>
                <span class="cov8" title="1">if v == 0 </span><span class="cov8" title="1">{
                        field.openCellArea(x-1, y-1, ID, cells)
                        field.openCellArea(x-1, y, ID, cells)
                        field.openCellArea(x-1, y+1, ID, cells)

                        field.openCellArea(x, y+1, ID, cells)
                        field.openCellArea(x, y-1, ID, cells)

                        field.openCellArea(x+1, y-1, ID, cells)
                        field.openCellArea(x+1, y, ID, cells)
                        field.openCellArea(x+1, y+1, ID, cells)
                }</span>
        }
}

// IsCleared return true if all safe cells except flags open
func (field *Field) IsCleared() bool <span class="cov8" title="1">{
        if field.getDone() </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">field.wGroup.Add(1)
        defer field.wGroup.Done()

        return field.getCellsLeft() == 0</span>
}

func (field *Field) saveCell(cell *Cell, cells *[]Cell) <span class="cov8" title="1">{
        if cell.Value != CellOpened &amp;&amp; cell.Value != CellFlagTaken </span><span class="cov8" title="1">{
                cell.Time = time.Now()
                field.setToHistory(*cell)
        }</span>
        <span class="cov8" title="1">*cells = append(*cells, *cell)</span>
}

// OpenCell open cell and return slice of opened cells
func (field *Field) OpenCell(cell *Cell) (cells []Cell) <span class="cov8" title="1">{
        if field.getDone() </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">field.wGroup.Add(1)
        defer field.wGroup.Done()

        cell.Value = field.getMatrixValue(cell.X, cell.Y)
        fmt.Printf("Cell(%d/%d)=%d", cell.X, cell.Y, cell.Value)

        cells = make([]Cell, 0)
        if cell.Value &lt; CellMine </span><span class="cov0" title="0">{
                field.openCellArea(cell.X, cell.Y, cell.PlayerID, &amp;cells)
        }</span> else<span class="cov8" title="1"> {
                if cell.Value != cell.PlayerID+CellIncrement </span><span class="cov8" title="1">{
                        field.saveCell(cell, &amp;cells)
                }</span>
        }

        <span class="cov8" title="1">return</span>
}

// RandomFlags create random players flags
func (field *Field) RandomFlags(players []Player) (cells []Cell) <span class="cov8" title="1">{
        if field.getDone() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">field.wGroup.Add(1)
        defer field.wGroup.Done()

        cells = make([]Cell, len(players))
        for i, player := range players </span><span class="cov8" title="1">{
                cells[i] = field.CreateRandomFlag(player.ID)
        }</span>
        <span class="cov8" title="1">return cells</span>
}

// CreateRandomFlag create flag for player
func (field *Field) CreateRandomFlag(playerID int) (cell Cell) <span class="cov8" title="1">{
        if field.getDone() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">field.wGroup.Add(1)
        defer field.wGroup.Done()

        rand.Seed(time.Now().UnixNano())
        x := rand.Intn(field.Width)
        y := rand.Intn(field.Height)
        cell = *NewCell(x, y, playerID+CellIncrement, playerID)

        return cell</span>
}

// SetMines fill matrix with mines
func (field *Field) SetMines() <span class="cov8" title="1">{
        if field.getDone() </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">field.wGroup.Add(1)
        defer field.wGroup.Done()

        width := field.Width
        height := field.Height
        mines := field.Mines
        fmt.Println("begin SetMines")
        for mines &gt; 0 </span><span class="cov0" title="0">{
                rand.Seed(time.Now().UnixNano())
                i := rand.Intn(width)
                j := rand.Intn(height)
                fmt.Println(i, j)
                if field.lessThenMine(i, j) </span><span class="cov0" title="0">{
                        field.setMine(i, j)
                        mines--
                }</span>
        }
        <span class="cov0" title="0">fmt.Println("end SetMines")</span>
}

// generate matrix
func generate(rs *models.RoomSettings) (matrix [][]int) <span class="cov8" title="1">{
        width := rs.Width
        height := rs.Height

        matrix = [][]int{}
        for i := 0; i &lt; height; i++ </span><span class="cov8" title="1">{
                matrix = append(matrix, make([]int, width))
        }</span>
        <span class="cov8" title="1">return</span>
}

// IsInside check if coordinates are in field
func (field Field) areCoordinatesRight(x, y int) bool <span class="cov8" title="1">{
        return x &gt;= 0 &amp;&amp; x &lt; field.Width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; field.Height
}</span>

// IsInside check is cell inside fueld
func (field Field) IsInside(cell *Cell) bool <span class="cov0" title="0">{
        return field.areCoordinatesRight(cell.X, cell.Y)
}</span>

///////////////////// Set cells func //////////

// SetFlag works only when mines not set
func (field *Field) SetFlag(cell *Cell) <span class="cov8" title="1">{
        if field.getDone() </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">field.wGroup.Add(1)
        defer field.wGroup.Done()

        // To identifier which flag we see, lets set id
        // add CellIncrement to id, because if id = 3 we can think that there are 3 mines around
        // we cant use -id, becase in future there will be a lot of conditions with
        // something &lt; 9 (to find not mine places)
        fmt.Println("setFlag", cell.X, cell.Y, cell.PlayerID, CellIncrement)

        field.setMatrixValue(cell.X, cell.Y, cell.PlayerID+CellIncrement)</span>
}

// SetCellFlagTaken set cells flag taken
func (field *Field) SetCellFlagTaken(cell *Cell) <span class="cov8" title="1">{
        if field.getDone() </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">field.wGroup.Add(1)
        defer field.wGroup.Done()

        field.setMatrixValue(cell.X, cell.Y, CellFlagTaken)

        fmt.Println("flag found!", cell.Value)</span>
}

// setCellOpen set cell opened
func (field *Field) setCellOpen(x, y int) <span class="cov8" title="1">{
        field.setMatrixValue(x, y, CellOpened)
}</span>

// setMine add mine to matrix and increase dangerous value in cells near mine
func (field *Field) setMine(x, y int) <span class="cov0" title="0">{

        width := field.Width
        height := field.Height
        field.setMatrixValue(x, y, CellMine)
        for i := x - 1; i &lt;= x+1; i++ </span><span class="cov0" title="0">{
                if i &gt;= 0 &amp;&amp; i &lt; width </span><span class="cov0" title="0">{
                        for j := y - 1; j &lt;= y+1; j++ </span><span class="cov0" title="0">{
                                if j &gt;= 0 &amp;&amp; j &lt; height </span><span class="cov0" title="0">{
                                        if field.lessThenMine(i, j) </span><span class="cov0" title="0">{
                                                field.incrementMatrixValue(i, j)
                                        }</span>
                                }
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package game

// setMatrixValue set a value to matrix
func (field *Field) setMatrixValue(x, y, v int) <span class="cov8" title="1">{
        field.matrixM.Lock()
        field.Matrix[x][y] = v
        field.matrixM.Unlock()
}</span>

// setMatrixValue set a value to matrix
func (field *Field) incrementMatrixValue(x, y int) <span class="cov0" title="0">{
        field.matrixM.Lock()
        field.Matrix[x][y]++
        field.matrixM.Unlock()
}</span>

// setMatrixValue set a value to matrix
func (field *Field) matrixFree() <span class="cov8" title="1">{
        field.matrixM.Lock()
        field.Matrix = nil
        field.matrixM.Unlock()
}</span>

// setMatrixValue set a value to matrix
func (field *Field) historyFree() <span class="cov8" title="1">{
        field.historyM.Lock()
        field.History = nil
        field.historyM.Unlock()
}</span>

// setMatrixValue set a value to matrix
func (field *Field) lessThenMine(x, y int) bool <span class="cov0" title="0">{
        field.matrixM.RLock()
        v := field.Matrix[x][y] &lt; CellMine
        field.matrixM.RUnlock()
        return v
}</span>

// getMatrixValue get a value from matrix
func (field *Field) getMatrixValue(x, y int) int <span class="cov8" title="1">{
        field.matrixM.RLock()
        v := field.Matrix[x][y]
        field.matrixM.RUnlock()
        return v
}</span>

// setMatrixValue set a value to matrix
func (field *Field) setToHistory(cell Cell) <span class="cov8" title="1">{
        field.historyM.Lock()
        defer field.historyM.Unlock()
        field.History = append(field.History, cell)
}</span>

// setMatrixValue set a value to matrix
func (field *Field) decrementCellsLeft() <span class="cov8" title="1">{
        field.cellsLeftM.Lock()
        field.CellsLeft--
        field.cellsLeftM.Unlock()
}</span>

// getMatrixValue get a value from matrix
func (field *Field) getCellsLeft() int <span class="cov8" title="1">{
        field.cellsLeftM.RLock()
        v := field.CellsLeft
        field.cellsLeftM.RUnlock()
        return v
}</span>

// setMatrixValue set a value to matrix
func (field *Field) setDone() <span class="cov8" title="1">{
        field.doneM.Lock()
        field.done = true
        field.doneM.Unlock()
}</span>

// getMatrixValue get a value from matrix
func (field *Field) getDone() bool <span class="cov8" title="1">{
        field.doneM.RLock()
        v := field.done
        field.doneM.RUnlock()
        return v
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package game

import (
        "context"
        "fmt"
        "sync"

        "github.com/go-park-mail-ru/2019_1_Escapade/internal/config"
        "github.com/go-park-mail-ru/2019_1_Escapade/internal/database"
        "github.com/go-park-mail-ru/2019_1_Escapade/internal/models"
)

// Request connect Connection and his message
type Request struct {
        Connection *Connection
        Message    []byte
}

// Lobby there are all rooms and users placed
type Lobby struct {
        wGroup *sync.WaitGroup

        doneM *sync.RWMutex
        _done bool

        allRoomsM *sync.RWMutex
        _AllRooms *Rooms

        freeRoomsM *sync.RWMutex
        _FreeRooms *Rooms

        waitingM *sync.RWMutex
        _Waiting *Connections

        playingM *sync.RWMutex
        _Playing *Connections

        messagesM *sync.Mutex
        _Messages []*models.Message

        context context.Context
        cancel  context.CancelFunc

        // connection joined lobby
        chanJoin chan *Connection
        // connection left lobby
        chanLeave chan *Connection

        chanBroadcast chan *Request

        chanBreak chan interface{}

        db            *database.DataBase
        canCloseRooms bool
}

// NewLobby create new instance of Lobby
func NewLobby(connectionsCapacity, roomsCapacity int,
        db *database.DataBase, canCloseRooms bool) *Lobby <span class="cov8" title="1">{

        var (
                messages []*models.Message
                err      error
        )
        if db != nil </span><span class="cov0" title="0">{
                if messages, err = db.LoadMessages(false, ""); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("cant load messages:", err.Error())
                }</span>
        } else<span class="cov8" title="1"> {
                messages = make([]*models.Message, 0)
        }</span>
        <span class="cov8" title="1">context, cancel := context.WithCancel(context.Background())
        lobby := &amp;Lobby{
                wGroup: &amp;sync.WaitGroup{},

                doneM: &amp;sync.RWMutex{},
                _done: false,

                allRoomsM: &amp;sync.RWMutex{},
                _AllRooms: NewRooms(roomsCapacity),

                freeRoomsM: &amp;sync.RWMutex{},
                _FreeRooms: NewRooms(roomsCapacity),

                waitingM: &amp;sync.RWMutex{},
                _Waiting: NewConnections(connectionsCapacity),

                playingM: &amp;sync.RWMutex{},
                _Playing: NewConnections(connectionsCapacity),

                messagesM: &amp;sync.Mutex{},
                _Messages: messages,

                context: context,
                cancel:  cancel,

                chanJoin:      make(chan *Connection),
                chanLeave:     make(chan *Connection),
                chanBroadcast: make(chan *Request),
                chanBreak:     make(chan interface{}),

                db:            db,
                canCloseRooms: canCloseRooms,
        }
        return lobby</span>
}

// lobby singleton
var (
        lobby *Lobby
)

// Launch launchs lobby goroutine
func Launch(gc *config.GameConfig, db *database.DataBase) <span class="cov8" title="1">{

        if lobby == nil </span><span class="cov8" title="1">{
                lobby = NewLobby(gc.ConnectionCapacity, gc.RoomsCapacity,
                        db, gc.CanClose)

                go lobby.Run(nil)
        }</span>
}

// GetLobby create lobby if it is nil and get it
func GetLobby() *Lobby <span class="cov8" title="1">{
        return lobby
}</span>

// Stop lobby goroutine
func (lobby *Lobby) Stop() <span class="cov0" title="0">{
        if lobby != nil </span><span class="cov0" title="0">{
                fmt.Println("Stop called!")
                lobby.chanBreak &lt;- nil
        }</span>
}

// Free delete all rooms and connections. Inform all players
// about closing
func (lobby *Lobby) Free() <span class="cov0" title="0">{

        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.setDone()

        go lobby.sendLobbyMessage("server closed", All)

        lobby.wGroup.Wait()

        fmt.Println("All resources clear!")

        go lobby.allRoomsFree()
        go lobby.freeRoomsFree()
        go lobby.waitingFree()
        go lobby.playingFree()

        lobby.cancel()

        close(lobby.chanJoin)
        close(lobby.chanLeave)
        close(lobby.chanBroadcast)
        lobby.db = nil
        lobby = nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package game

import (
        "sync"

        "github.com/go-park-mail-ru/2019_1_Escapade/internal/models"
        "github.com/go-park-mail-ru/2019_1_Escapade/internal/utils"

        "encoding/json"
        "fmt"
)

func (lobby *Lobby) JoinConn(conn *Connection) <span class="cov8" title="1">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                utils.CatchPanic("lobby_handle.go Join()")
                lobby.wGroup.Done()
        }</span>()
        <span class="cov8" title="1">lobby.chanJoin &lt;- conn</span>
}

// Run the room in goroutine
func (lobby *Lobby) Run(wg *sync.WaitGroup) <span class="cov8" title="1">{
        defer func() </span><span class="cov0" title="0">{
                utils.CatchPanic("lobby_handle.go Run()")
                lobby.Free()
        }</span>()

        //var lobbyCancel context.CancelFunc
        //lobby.Context, lobbyCancel = context.WithCancel(context.Background())
        <span class="cov8" title="1">if wg != nil </span><span class="cov0" title="0">{
                wg.Done()
        }</span>
        <span class="cov8" title="1">fmt.Println("Lobby run")
        for </span><span class="cov8" title="1">{
                select </span>{
                case connection := &lt;-lobby.chanJoin:<span class="cov8" title="1">
                        go lobby.Join(connection)</span>

                case message := &lt;-lobby.chanBroadcast:<span class="cov8" title="1">
                        go lobby.Analize(message)</span>

                        // TODO delete chanleavem cause Leave call direcrly
                case connection := &lt;-lobby.chanLeave:<span class="cov8" title="1">
                        lobby.Leave(connection, "You disconnected!")</span>
                        // if need_stop {
                        //         if len(lobby.Playing.Get)+len(lobby.Waiting.Get) == 0 {
                        //                 fmt.Println("Nobody there!")
                        //                 lobbyCancel()
                        //                 return
                        //         }
                        // }
                case &lt;-lobby.chanBreak:<span class="cov0" title="0">
                        fmt.Println("Stop saw!")
                        return</span>
                }
        }
}

// Join handle user join to lobby
func (lobby *Lobby) Join(newConn *Connection) <span class="cov8" title="1">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                utils.CatchPanic("lobby_handle.go Join()")
                lobby.wGroup.Done()
        }</span>()

        <span class="cov8" title="1">lobby.addWaiter(newConn)

        if lobby.recoverInRoom(newConn) </span><span class="cov0" title="0">{
                go lobby.sendPlayerEnter(*newConn, AllExceptThat(newConn))
                return
        }</span>

        <span class="cov0" title="0">go lobby.sendWaiterEnter(*newConn, AllExceptThat(newConn))

        newConn.debug("new waiter")</span>
}

// Leave handle user leave lobby
func (lobby *Lobby) Leave(conn *Connection, message string) <span class="cov8" title="1">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">lobby.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                utils.CatchPanic("lobby_handle.go Leave()")
                lobby.wGroup.Done()
        }</span>()

        <span class="cov8" title="1">fmt.Println("disconnected -  #", conn.ID())

        if !conn.InRoom() </span><span class="cov8" title="1">{
                go lobby.waitingRemove(conn)
                go lobby.sendWaiterExit(*conn, AllExceptThat(conn))
        }</span>

        <span class="cov8" title="1">fmt.Println("here ", conn.Both(), conn.InRoom())
        if conn.Both() || conn.InRoom() </span><span class="cov0" title="0">{
                fmt.Println("both -  #", conn.ID())
                go lobby.LeaveRoom(conn, conn.Room(), ActionDisconnect)
        }</span>
        <span class="cov8" title="1">return</span>
}

// LeaveRoom handle leave room
func (lobby *Lobby) LeaveRoom(conn *Connection, room *Room, action int) <span class="cov0" title="0">{

        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                utils.CatchPanic("lobby_handle.go LeaveRoom()")
                lobby.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">fmt.Println("check", action, ActionDisconnect)
        if action != ActionDisconnect </span><span class="cov0" title="0">{
                lobby.PlayerToWaiter(conn)
        }</span> else<span class="cov0" title="0"> {
                //go lobby.playingRemove(conn)
                go lobby.sendPlayerExit(*conn, AllExceptThat(conn))
        }</span>

        <span class="cov0" title="0">room.Leave(conn, action) // exit to lobby
        if len(room.playersConnections()) &gt; 0 </span><span class="cov0" title="0">{
                go lobby.sendRoomUpdate(*room, AllExceptThat(conn))
        }</span>
}

// EnterRoom handle user join to room
func (lobby *Lobby) EnterRoom(conn *Connection, rs *models.RoomSettings) <span class="cov8" title="1">{

        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                utils.CatchPanic("lobby_handle.go EnterRoom()")
                lobby.wGroup.Done()
        }</span>()

        <span class="cov8" title="1">conn.actionSem &lt;- struct{}{}
        defer func() </span><span class="cov0" title="0">{ &lt;-conn.actionSem }</span>()

        <span class="cov8" title="1">fmt.Println("EnterRoom", rs)
        if conn.InRoom() </span><span class="cov0" title="0">{
                fmt.Println("in room", rs)
                fmt.Println("EnterRoom ID compare", conn.RoomID(), rs.ID, rs)
                if conn.RoomID() == rs.ID </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">lobby.LeaveRoom(conn, conn.Room(), ActionBackToLobby)
                conn.debug("change room")</span>
        }

        <span class="cov8" title="1">fmt.Println("not in room", rs.ID, rs.ID == "create", conn.ID())
        conn.debug("enter room" + rs.ID)
        if rs.ID == "create" </span><span class="cov0" title="0">{
                fmt.Println("you wanna crete room", rs)
                conn.debug("see you wanna create room?")
                lobby.CreateAndAddToRoom(rs, conn)
                return
        }</span>

        <span class="cov0" title="0">if _, room := lobby.allRoomsSearch(rs.ID); room != nil </span><span class="cov0" title="0">{
                conn.debug("lobby found required room")
                room.Enter(conn)
        }</span> else<span class="cov0" title="0"> {
                conn.debug("lobby search room for you")
                lobby.PickUpRoom(conn, rs)
        }</span>

}

// pickUpRoom find room for player
func (lobby *Lobby) PickUpRoom(conn *Connection, rs *models.RoomSettings) (room *Room) <span class="cov0" title="0">{

        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                utils.CatchPanic("lobby_handle.go PickUpRoom()")
                lobby.wGroup.Done()
        }</span>()

        // lets find room for user
        <span class="cov0" title="0">FreeRooms := lobby.freeRooms()
        for _, room = range FreeRooms </span><span class="cov0" title="0">{
                //if room.SameAs()
                if room.addPlayer(conn) </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        // oh we cant find room, so lets create one
        <span class="cov0" title="0">lobby.CreateAndAddToRoom(rs, conn)
        return</span>
}

// analize handle where the connection sends the request
func (lobby *Lobby) Analize(req *Request) <span class="cov8" title="1">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">lobby.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                utils.CatchPanic("lobby_handle.go Analize()")
                lobby.wGroup.Done()
        }</span>()

        <span class="cov8" title="1">if req.Connection.Both() || !req.Connection.InRoom() </span><span class="cov8" title="1">{
                var send *LobbyRequest
                if err := json.Unmarshal(req.Message, &amp;send); err != nil </span><span class="cov0" title="0">{
                        req.Connection.SendInformation(err)
                }</span> else<span class="cov8" title="1"> {
                        go lobby.HandleRequest(req.Connection, send)
                }</span>
        }
        <span class="cov8" title="1">if req.Connection.Both() || req.Connection.InRoom() </span><span class="cov0" title="0">{
                if req.Connection.Room() == nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">var send *RoomRequest
                if err := json.Unmarshal(req.Message, &amp;send); err != nil </span><span class="cov0" title="0">{
                        req.Connection.SendInformation(err)
                }</span> else<span class="cov0" title="0"> {
                        room := req.Connection.Room()
                        if room == nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">room.HandleRequest(req.Connection, send)</span>
                }
        }
}

// handleRequest handle any request sent to lobby
func (lobby *Lobby) HandleRequest(conn *Connection, lr *LobbyRequest) <span class="cov8" title="1">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                utils.CatchPanic("lobby_handle.go HandleRequest()")
                lobby.wGroup.Done()
        }</span>()

        <span class="cov8" title="1">if lr.IsGet() </span><span class="cov0" title="0">{
                go lobby.greet(conn)
        }</span> else<span class="cov8" title="1"> if lr.IsSend() </span><span class="cov8" title="1">{
                if lr.Send.RoomSettings == nil </span><span class="cov8" title="1">{
                        conn.debug("lobby cant execute request")
                        return
                }</span>
                <span class="cov8" title="1">lobby.EnterRoom(conn, lr.Send.RoomSettings)</span>
        } else<span class="cov0" title="0"> if lr.Message != nil </span><span class="cov0" title="0">{
                Message(lobby, conn, lr.Message, lobby.setToMessages,
                        lobby.send, All, false, "")
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package game

import (
        "fmt"
        "sync"

        "github.com/gorilla/websocket"

        "github.com/go-park-mail-ru/2019_1_Escapade/internal/database"

        "github.com/go-park-mail-ru/2019_1_Escapade/internal/config"
        "github.com/go-park-mail-ru/2019_1_Escapade/internal/models"
)

// LaunchLobbyHistory launch local lobby with rooms from database
func LaunchLobbyHistory(db *database.DataBase,
        ws *websocket.Conn, user *models.UserPublicInfo,
        WSsettings config.WebSocketSettings, gameSettings config.GameConfig) <span class="cov0" title="0">{

        urls, err := db.GetGamesURL(user.ID)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("GetGamesURL", err.Error())
                return
        }</span>

        <span class="cov0" title="0">lobby := NewLobby(gameSettings.ConnectionCapacity, len(urls),
                db, gameSettings.CanClose)
        all := &amp;sync.WaitGroup{}
        all.Add(1)
        go lobby.Run(all)
        defer func() </span><span class="cov0" title="0">{
                fmt.Println("stop lobby!")
                lobby.Stop()
        }</span>()

        <span class="cov0" title="0">all.Wait()
        err = lobby.LoadRooms(urls)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("LoadRooms", err.Error())
                return
        }</span>

        <span class="cov0" title="0">conn := NewConnection(ws, user, lobby)
        conn.Launch(WSsettings)</span>

}
</pre>
		
		<pre class="file" id="file10" style="display: none">package game

import (
        "encoding/json"

        "github.com/go-park-mail-ru/2019_1_Escapade/internal/models"
)

// Room consist of players and observers, field and history
type LobbyJSON struct {
        AllRooms  Rooms             `json:"allRooms"`
        FreeRooms Rooms             `json:"freeRooms"`
        Waiting   Connections       `json:"waiting"`
        Playing   Connections       `json:"playing"`
        Messages  []*models.Message `json:"messages"`
}

func (lobby *Lobby) JSON() LobbyJSON <span class="cov8" title="1">{
        return LobbyJSON{
                AllRooms:  *lobby._AllRooms,
                FreeRooms: *lobby._FreeRooms,
                Waiting:   *lobby._Waiting,
                Playing:   *lobby._Playing,
                Messages:  lobby._Messages,
        }
}</span>

func (lobby Lobby) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(lobby.JSON())
}</span>

func (lobby *Lobby) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        temp := &amp;LobbyJSON{}

        if err := json.Unmarshal(b, &amp;temp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">lobby._AllRooms = &amp;temp.AllRooms
        lobby._FreeRooms = &amp;temp.FreeRooms
        lobby._Waiting = &amp;temp.Waiting
        lobby._Playing = &amp;temp.Playing
        lobby._Messages = temp.Messages

        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package game

import (
        "github.com/go-park-mail-ru/2019_1_Escapade/internal/models"
        "github.com/go-park-mail-ru/2019_1_Escapade/internal/utils"
)

// setMatrixValue set a value to matrix
func (lobby *Lobby) setDone() <span class="cov0" title="0">{
        lobby.doneM.Lock()
        lobby._done = true
        lobby.doneM.Unlock()
}</span>

// getMatrixValue get a value from matrix
func (lobby *Lobby) done() bool <span class="cov8" title="1">{
        lobby.doneM.RLock()
        v := lobby._done
        lobby.doneM.RUnlock()
        return v
}</span>

// getMatrixValue get a value from matrix
func (lobby *Lobby) allRoomsFree() <span class="cov0" title="0">{
        lobby.allRoomsM.Lock()
        defer lobby.allRoomsM.Unlock()
        lobby._AllRooms.Free()
}</span>

// getMatrixValue get a value from matrix
func (lobby *Lobby) freeRoomsFree() <span class="cov0" title="0">{
        lobby.freeRoomsM.Lock()
        defer lobby.freeRoomsM.Unlock()
        lobby._FreeRooms.Free()
}</span>

// getMatrixValue get a value from matrix
func (lobby *Lobby) waitingFree() <span class="cov0" title="0">{
        lobby.waitingM.Lock()
        defer lobby.waitingM.Unlock()
        lobby._Waiting.Free()
}</span>

// getMatrixValue get a value from matrix
func (lobby *Lobby) playingFree() <span class="cov0" title="0">{
        lobby.playingM.Lock()
        defer lobby.playingM.Unlock()
        lobby._Playing.Free()
}</span>

// getMatrixValue get a value from matrix
func (lobby *Lobby) waiting() []*Connection <span class="cov8" title="1">{
        lobby.waitingM.RLock()
        defer lobby.waitingM.RUnlock()
        v := lobby._Waiting.Get

        return v
}</span>

// getMatrixValue get a value from matrix
func (lobby *Lobby) playing() []*Connection <span class="cov0" title="0">{
        lobby.playingM.RLock()
        defer lobby.playingM.RUnlock()
        v := lobby._Playing.Get

        return v
}</span>

// getMatrixValue get a value from matrix
func (lobby *Lobby) playingRemove(conn *Connection) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                utils.CatchPanic("lobby_mutex.go playingRemove()")
                lobby.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">lobby.playingM.Lock()
        defer lobby.playingM.Unlock()
        lobby._Playing.Remove(conn)</span>
}

// getMatrixValue get a value from matrix
func (lobby *Lobby) playingAdd(conn *Connection) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                utils.CatchPanic("lobby_mutex.go playingRemove()")
                lobby.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">lobby.playingM.Lock()
        defer lobby.playingM.Unlock()
        lobby._Playing.Add(conn, false)</span>
}

// getMatrixValue get a value from matrix
func (lobby *Lobby) waitingRemove(conn *Connection) <span class="cov8" title="1">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">lobby.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                utils.CatchPanic("lobby_mutex.go waitingRemove()")
                lobby.wGroup.Done()
        }</span>()

        <span class="cov8" title="1">lobby.waitingM.Lock()
        defer lobby.waitingM.Unlock()
        lobby._Waiting.Remove(conn)</span>
}

// getMatrixValue get a value from matrix
func (lobby *Lobby) waitingAdd(conn *Connection) <span class="cov8" title="1">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">lobby.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                utils.CatchPanic("lobby_mutex.go waitingAdd()")
                lobby.wGroup.Done()
        }</span>()

        <span class="cov8" title="1">lobby.waitingM.Lock()
        defer lobby.waitingM.Unlock()
        lobby._Waiting.Add(conn, false)</span>
}

// getMatrixValue get a value from matrix
func (lobby *Lobby) allRoomsSearch(roomID string) (int, *Room) <span class="cov0" title="0">{
        lobby.allRoomsM.RLock()
        defer lobby.allRoomsM.RUnlock()
        index, room := lobby._AllRooms.SearchRoom(roomID)
        return index, room
}</span>

// getMatrixValue get a value from matrix
func (lobby *Lobby) allRoomsSearchPlayer(conn *Connection) (int, *Room) <span class="cov0" title="0">{
        lobby.allRoomsM.RLock()
        defer lobby.allRoomsM.RUnlock()
        index, room := lobby._AllRooms.SearchPlayer(conn)
        return index, room
}</span>

// getMatrixValue get a value from matrix
func (lobby *Lobby) allRoomsSearchObserver(conn *Connection) *Connection <span class="cov0" title="0">{
        lobby.allRoomsM.RLock()
        defer lobby.allRoomsM.RUnlock()
        old := lobby._AllRooms.SearchObserver(conn)
        return old
}</span>

// getMatrixValue get a value from matrix
func (lobby *Lobby) freeRoomsEmpty() bool <span class="cov0" title="0">{
        lobby.freeRoomsM.RLock()
        defer lobby.freeRoomsM.RUnlock()
        v := lobby._FreeRooms.Empty()
        return v
}</span>

// getMatrixValue get a value from matrix
func (lobby *Lobby) freeRooms() []*Room <span class="cov0" title="0">{
        lobby.freeRoomsM.RLock()
        defer lobby.freeRoomsM.RUnlock()
        v := lobby._FreeRooms.Get
        return v
}</span>

// getMatrixValue get a value from matrix
func (lobby *Lobby) setToMessages(message *models.Message) <span class="cov0" title="0">{
        lobby.messagesM.Lock()
        defer lobby.messagesM.Unlock()
        lobby._Messages = append(lobby._Messages, message)
}</span>

// getMatrixValue get a value from matrix
func (lobby *Lobby) freeRoomsRemove(room *Room) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                utils.CatchPanic("lobby_mutex.go freeRoomsRemove()")
                lobby.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">lobby.freeRoomsM.Lock()
        defer lobby.freeRoomsM.Unlock()
        lobby._FreeRooms.Remove(room)</span>
}

// getMatrixValue get a value from matrix
func (lobby *Lobby) allRoomsRemove(room *Room) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                utils.CatchPanic("lobby_mutex.go allRoomsRemove()")
                lobby.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">lobby.allRoomsM.Lock()
        defer lobby.allRoomsM.Unlock()
        lobby._AllRooms.Remove(room)</span>
}

// getMatrixValue get a value from matrix
func (lobby *Lobby) freeRoomsAdd(room *Room) bool <span class="cov0" title="0">{
        lobby.freeRoomsM.Lock()
        defer lobby.freeRoomsM.Unlock()
        v := lobby._FreeRooms.Add(room)
        return v
}</span>

// getMatrixValue get a value from matrix
func (lobby *Lobby) allRoomsAdd(room *Room) bool <span class="cov0" title="0">{
        lobby.allRoomsM.Lock()
        defer lobby.allRoomsM.Unlock()
        v := lobby._AllRooms.Add(room)
        return v
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package game

import (
        "fmt"

        "github.com/go-park-mail-ru/2019_1_Escapade/internal/utils"
        "github.com/go-park-mail-ru/2019_1_Escapade/internal/metrics"
)

func (lobby *Lobby) addWaiter(newConn *Connection) <span class="cov8" title="1">{
        metrics.WaitingPlayers.Add(1)
        fmt.Println("addWaiter called")
        go lobby.waitingAdd(newConn)
        if !newConn.Both() </span><span class="cov8" title="1">{
                lobby.greet(newConn)
        }</span>
}

func (lobby *Lobby) addPlayer(newConn *Connection) <span class="cov0" title="0">{
        fmt.Println("addPlayer called")
        lobby.playingAdd(newConn)
}</span>

func (lobby *Lobby) waiterToPlayer(newConn *Connection) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                utils.CatchPanic("lobby_handle.go waiterToPlayer()")
                lobby.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">fmt.Println("waiterToPlayer called")
        lobby.waitingRemove(newConn)
        lobby.addPlayer(newConn)</span>
}

func (lobby *Lobby) PlayerToWaiter(conn *Connection) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                utils.CatchPanic("lobby_handle.go PlayerToWaiter()")
                lobby.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">fmt.Println("PlayerToWaiter called")
        lobby.playingRemove(conn)
        lobby.addWaiter(conn)
        conn.PushToLobby()</span>
}

func (lobby *Lobby) recoverInRoom(newConn *Connection) bool <span class="cov0" title="0">{
        // find such player
        i, room := lobby.allRoomsSearchPlayer(newConn)

        if i &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("we found you in game!")
                room.RecoverPlayer(newConn)
                return true
        }</span>

        // find such observer
        <span class="cov0" title="0">old := lobby.allRoomsSearchObserver(newConn)
        if old != nil </span><span class="cov0" title="0">{
                room = old.Room()
                if room == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">room.RecoverObserver(old, newConn)
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package game

import (
        "github.com/go-park-mail-ru/2019_1_Escapade/internal/models"
)

// LobbyRequest - client send it by websocket to
// send/get information from Lobby
type LobbyRequest struct {
        Send    *LobbySend      `json:"send"`
        Message *models.Message `json:"message"`
        Get     *LobbyGet       `json:"get"`
}

// NewLobbyRequest creates Lobby instance
func NewLobbyRequest(s *LobbySend, g *LobbyGet) *LobbyRequest <span class="cov0" title="0">{
        return &amp;LobbyRequest{
                Send: s,
                Get:  g,
        }
}</span>

// IsGet checks, if client want get info
func (lr *LobbyRequest) IsGet() bool <span class="cov8" title="1">{
        return lr.Get != nil
}</span>

// IsSend checks, if client want send info
func (lr *LobbyRequest) IsSend() bool <span class="cov8" title="1">{
        return lr.Send != nil
}</span>

// LobbySend - Information, that client can send to lobby
type LobbySend struct {
        RoomSettings *models.RoomSettings
}

// LobbyGet - Information, that client can get from lobby
type LobbyGet struct {
        AllRooms  bool `json:"allRooms"`
        FreeRooms bool `json:"freeRooms"`
        Waiting   bool `json:"waiting"`
        Playing   bool `json:"playing"`
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package game

import (
        "github.com/go-park-mail-ru/2019_1_Escapade/internal/metrics"
        "github.com/go-park-mail-ru/2019_1_Escapade/internal/models"
        re "github.com/go-park-mail-ru/2019_1_Escapade/internal/return_errors"
        "github.com/go-park-mail-ru/2019_1_Escapade/internal/utils"

        "fmt"
)

// ----- handle room status
// roomStart - room remove from free
func (lobby *Lobby) RoomStart(room *Room) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("lobby_room.go RoomStart()")
        }</span>()

        <span class="cov0" title="0">metrics.FreeRooms.Add(-1)
        go lobby.freeRoomsRemove(room)
        go lobby.sendRoomUpdate(*room, All)</span>
}

// roomFinish - room remove from all
func (lobby *Lobby) roomFinish(room *Room) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("lobby_room.go roomFinish()")
        }</span>()

        <span class="cov0" title="0">metrics.Rooms.Add(-1)
        go lobby.allRoomsRemove(room)
        go lobby.sendRoomUpdate(*room, All)</span>
}

// CloseRoom free room resources
func (lobby *Lobby) CloseRoom(room *Room) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("lobby_room.go roomFinish()")
        }</span>()

        // if not in freeRooms nothing bad will happen
        // there is check inside, it will just return without errors
        <span class="cov0" title="0">lobby.freeRoomsRemove(room)
        lobby.allRoomsRemove(room)
        fmt.Println("sendRoomDelete")
        go lobby.sendRoomDelete(*room, All)</span>
}

// createAndAddToRoom create room and add player to it
func (lobby *Lobby) CreateAndAddToRoom(rs *models.RoomSettings, conn *Connection) (room *Room, err error) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                utils.CatchPanic("lobby_room.go CreateAndAddToRoom()")
                lobby.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">if room, err = lobby.createRoom(rs); err == nil </span><span class="cov0" title="0">{
                conn.debug("We create your own room, cool!")
                room.addPlayer(conn)
        }</span> else<span class="cov0" title="0"> {
                conn.debug("cant create. Why?")
                room.sendError(err, *conn)
        }</span>
        <span class="cov0" title="0">return</span>
}

// createRoom create room, add to all and free rooms
// and run it
func (lobby *Lobby) createRoom(rs *models.RoomSettings) (room *Room, err error) <span class="cov0" title="0">{

        id := utils.RandomString(16) // вынести в кофиг
        if room, err = NewRoom(rs, id, lobby); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if err = lobby.addRoom(room); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return</span>
}

// LoadRooms load rooms from database
func (lobby *Lobby) LoadRooms(URLs []string) error <span class="cov0" title="0">{

        if lobby.done() </span><span class="cov0" title="0">{
                return re.ErrorLobbyDone()
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                utils.CatchPanic("lobby_room.go LoadRooms()")
                lobby.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">for _, URL := range URLs </span><span class="cov0" title="0">{
                room, err := lobby.Load(URL)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err = lobby.addRoom(room); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (lobby *Lobby) addRoom(room *Room) (err error) <span class="cov0" title="0">{
        metrics.Rooms.Add(1)
        metrics.FreeRooms.Add(1)

        if !lobby.allRoomsAdd(room) </span><span class="cov0" title="0">{
                err = re.ErrorLobbyCantCreateRoom()
                fmt.Println("cant add to all")
                return err
        }</span>

        <span class="cov0" title="0">if !lobby.freeRoomsAdd(room) </span><span class="cov0" title="0">{
                err = re.ErrorLobbyCantCreateRoom()
                fmt.Println("cant add to free")
                return err
        }</span>

        <span class="cov0" title="0">go lobby.sendRoomCreate(*room, All) // inform all about new room
        return</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package game

import (
        "fmt"

        "github.com/go-park-mail-ru/2019_1_Escapade/internal/models"
        "github.com/go-park-mail-ru/2019_1_Escapade/internal/utils"
)

// all senders functions should add 1 to waitGroup!
// also all thay should be launched in goroutines and
// recover panic

func (lobby *Lobby) send(info interface{}, predicate SendPredicate) <span class="cov8" title="1">{
        SendToConnections(info, predicate, lobby.waiting())
}</span>

func (lobby *Lobby) sendToAll(info interface{}, predicate SendPredicate) <span class="cov0" title="0">{
        SendToConnections(info, predicate, lobby.waiting(), lobby.playing())
}</span>

func (lobby *Lobby) greet(conn *Connection) <span class="cov8" title="1">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("lobby greet")
        }</span>()

        <span class="cov8" title="1">response := models.Response{
                Type: "Lobby",
                Value: struct {
                        Lobby Lobby                 `json:"lobby"`
                        You   models.UserPublicInfo `json:"you"`
                }{
                        Lobby: *lobby,
                        You:   *conn.User,
                },
        }
        fmt.Println("greet")
        conn.SendInformation(response)</span>
}

func (lobby *Lobby) sendLobbyMessage(message string, predicate SendPredicate) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("lobby sendLobbyMessage")
        }</span>()

        <span class="cov0" title="0">response := models.Response{
                Type:  "LobbyMessage",
                Value: message,
        }
        lobby.sendToAll(response, predicate)</span>
}

func (lobby *Lobby) sendRoomCreate(room Room, predicate SendPredicate) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("lobby sendRoomCreate")
        }</span>()

        <span class="cov0" title="0">response := models.Response{
                Type:  "LobbyRoomCreate",
                Value: room.JSON(),
        }
        lobby.send(response, predicate)</span>
}

func (lobby *Lobby) sendRoomUpdate(room Room, predicate SendPredicate) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("lobby sendRoomUpdate")
        }</span>()

        <span class="cov0" title="0">response := models.Response{
                Type:  "LobbyRoomUpdate",
                Value: room.JSON(),
        }
        lobby.send(response, predicate)</span>
}

func (lobby *Lobby) sendRoomDelete(room Room, predicate SendPredicate) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("lobby sendRoomDelete")
        }</span>()

        <span class="cov0" title="0">response := models.Response{
                Type:  "LobbyRoomDelete",
                Value: room.ID,
        }
        lobby.send(response, predicate)</span>
}

func (lobby *Lobby) sendWaiterEnter(conn Connection, predicate SendPredicate) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("lobby sendWaiterEnter")
        }</span>()

        <span class="cov0" title="0">response := models.Response{
                Type:  "LobbyWaiterEnter",
                Value: conn,
        }
        lobby.send(response, predicate)</span>
}

func (lobby *Lobby) sendWaiterExit(conn Connection, predicate SendPredicate) <span class="cov8" title="1">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">lobby.wGroup.Add(1)
        defer func() </span><span class="cov8" title="1">{
                lobby.wGroup.Done()
                utils.CatchPanic("lobby sendWaiterExit")
        }</span>()

        <span class="cov8" title="1">response := models.Response{
                Type:  "LobbyWaiterExit",
                Value: conn,
        }
        lobby.send(response, predicate)</span>
}

func (lobby *Lobby) sendPlayerEnter(conn Connection, predicate SendPredicate) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("lobby sendPlayerEnter")
        }</span>()

        <span class="cov0" title="0">response := models.Response{
                Type:  "LobbyPlayerEnter",
                Value: conn,
        }
        lobby.send(response, predicate)</span>
}

func (lobby *Lobby) sendPlayerExit(conn Connection, predicate SendPredicate) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("lobby sendPlayerExit")
        }</span>()

        <span class="cov0" title="0">response := models.Response{
                Type:  "LobbyPlayerExit",
                Value: conn,
        }
        lobby.send(response, predicate)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package game

import (
        "time"

        "github.com/go-park-mail-ru/2019_1_Escapade/internal/models"
)

// Sender is the func that send information to connections
type Sender func(interface{}, SendPredicate)

type SetToMessages func(message *models.Message)

// Message send message to connections
func Message(lobby *Lobby, conn *Connection,
        message *models.Message, setToMessages SetToMessages,
        send Sender, predicate SendPredicate, inRoom bool, roomID string) <span class="cov0" title="0">{
        message.User = conn.User
        message.Time = time.Now()
        setToMessages(message)
        lobby.db.SaveMessage(message, inRoom, roomID)

        response := models.Response{
                Type:  "GameMessage",
                Value: message,
        }
        send(response, predicate)

}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package game

// Player has name, ID, points and flag Finish
type Player struct {
        ID       int
        Points   int
        Finished bool
        Died     bool
}

// NewPlayer create new instance of Player
func NewPlayer(id int) *Player <span class="cov8" title="1">{
        player := &amp;Player{
                ID:     id,
                Points: 0,
        }
        return player
}</span>

// SetAsPlayer set Finished = false
func (player *Player) SetAsPlayer() <span class="cov0" title="0">{
        player.Points = 0
        player.Finished = false
}</span>

// SetAsObserver set Finished = true
func (player *Player) SetAsObserver() <span class="cov0" title="0">{
        player.Points = 0
        player.Finished = true
}</span>

/*
During the game the room doesnt know status of that player
(is he gamer or observer). Every player can send cell and
action. But the room process these requests only from players,
which 'finish' flag is false(except action - Back to menu)
*/

// IsAlive check is player alive
func (player *Player) IsAlive() bool <span class="cov0" title="0">{
        return player.Finished == false
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package game

import (
        "fmt"
        "sync"
        "time"

        "github.com/go-park-mail-ru/2019_1_Escapade/internal/models"
        re "github.com/go-park-mail-ru/2019_1_Escapade/internal/return_errors"
)

// Game status
const (
        StatusPeopleFinding = 0
        StatusAborted       = 1 // in case of error
        StatusFlagPlacing   = 2
        StatusRunning       = 3
        StatusFinished      = 4
)

// Room consist of players and observers, field and history
type Room struct {
        wGroup *sync.WaitGroup

        doneM *sync.RWMutex
        _done bool

        playersM *sync.RWMutex
        _Players *OnlinePlayers

        observersM *sync.RWMutex
        _Observers *Connections

        historyM *sync.RWMutex
        _History []*PlayerAction

        messagesM *sync.Mutex
        _Messages []*models.Message

        killedM *sync.RWMutex
        _killed int //amount of killed users

        ID     string
        Name   string
        Status int

        lobby *Lobby
        Field *Field

        Date       time.Time
        chanFinish chan struct{}

        Settings *models.RoomSettings
}

// NewRoom return new instance of room
func NewRoom(rs *models.RoomSettings, id string, lobby *Lobby) (*Room, error) <span class="cov8" title="1">{
        fmt.Println("NewRoom rs = ", *rs)
        if !rs.AreCorrect() </span><span class="cov0" title="0">{
                return nil, re.ErrorInvalidRoomSettings()
        }</span>
        <span class="cov8" title="1">field := NewField(rs)
        room := &amp;Room{
                wGroup: &amp;sync.WaitGroup{},

                doneM: &amp;sync.RWMutex{},
                _done: false,

                playersM: &amp;sync.RWMutex{},
                _Players: newOnlinePlayers(rs.Players, *field),

                observersM: &amp;sync.RWMutex{},
                _Observers: NewConnections(rs.Observers),

                historyM: &amp;sync.RWMutex{},
                _History: make([]*PlayerAction, 0),

                messagesM: &amp;sync.Mutex{},
                _Messages: make([]*models.Message, 0),

                killedM: &amp;sync.RWMutex{},
                _killed: 0,

                ID:     id,
                Name:   rs.Name,
                Status: StatusPeopleFinding,

                lobby: lobby,
                Field: field,

                Date:       time.Now(),
                chanFinish: make(chan struct{}),

                Settings: rs,
        }
        return room, nil</span>
}

func (room *Room) debug() <span class="cov0" title="0">{
        if room == nil </span><span class="cov0" title="0">{
                fmt.Println("cant debug nil room")
                return
        }</span>
        <span class="cov0" title="0">fmt.Println("Room id    :", room.ID)
        fmt.Println("Room name  :", room.Name)
        fmt.Println("Room status:", room.Status)
        fmt.Println("Room date  :", room.Date)
        fmt.Println("Room killed:", room.killed())
        players := room.players()
        if len(players) == 0 </span><span class="cov0" title="0">{
                fmt.Println("cant debug nil players")
                return
        }</span>
        <span class="cov0" title="0">for _, player := range players </span><span class="cov0" title="0">{
                fmt.Println("Player", player.ID)
                fmt.Println("Player points         :", player.Points)
                fmt.Println("Player Finished:", player.Finished)
        }</span>
        <span class="cov0" title="0">if room.Field == nil </span><span class="cov0" title="0">{
                fmt.Println("cant debug nil field")
                return
        }</span>
        <span class="cov0" title="0">fmt.Println("Field width                :", room.Field.Width)
        fmt.Println("Field height         :", room.Field.Height)
        fmt.Println("Field cellsleft:", room.Field.CellsLeft)
        fmt.Println("Field mines                :", room.Field.Mines)
        if room.Field.History == nil </span><span class="cov0" title="0">{
                fmt.Println("no field history")
        }</span> else<span class="cov0" title="0"> {
                for _, cell := range room.Field.History </span><span class="cov0" title="0">{
                        fmt.Printf("Cell(%d,%d) with value %d", cell.X, cell.Y, cell.Value)
                        fmt.Println("Cell Owner        :", cell.PlayerID)
                        fmt.Println("Cell Time  :", cell.Time)
                }</span>
        }
        <span class="cov0" title="0">history := room.history()
        if history == nil </span><span class="cov0" title="0">{
                fmt.Println("no action history")
        }</span> else<span class="cov0" title="0"> {
                for i, action := range history </span><span class="cov0" title="0">{
                        fmt.Println("action", i)
                        fmt.Println("action value  :", action.Action)
                        fmt.Println("action Owner        :", action.Player)
                        fmt.Println("action Time  :", action.Time)
                }</span>
        }

}

// SameAs compare  one room with another
func (room *Room) SameAs(another *Room) bool <span class="cov0" title="0">{
        return room.Field.SameAs(another.Field)
}</span>

/* Examples of json

message
{"message":{"text":"hello"}}


room search
{"send":{"RoomSettings":{"name":"my best room","id":"create","width":12,"height":12,"players":2,"observers":10,"prepare":10, "play":100, "mines":5}},"get":null}

send cell
{"send":{"cell":{"x":2,"y":1,"value":0,"PlayerID":0}, "action":null},"get":null}

send action(all actions are in action.go). Server iswaiting only one of these:
ActionStop 5
ActionContinue 6
ActionGiveUp 13
ActionBackToLobby 14

give up
{"send":{"cell":null, "action":13,"get":null}}

back to lobby
{"send":{"cell":null, "action":14,"get":null}}

get lobby all info
{"send":null,"get":{"allRooms":true,"freeRooms":true,"waiting":true,"playing":true}}

        Players   bool `json:"players"`
        Observers bool `json:"observers"`
        Field     bool `json:"field"`
        History   bool `json:"history"`
{"send":null,"get":{"players":true,"observers":true,"field":true,"history":true}}
*/

// RoomRequest is request from client to room
type RoomRequest struct {
        Send    *RoomSend       `json:"send"`
        Message *models.Message `json:"message"`
        Get     *RoomGet        `json:"get"`
}

// IsGet check if client want get information
func (rr *RoomRequest) IsGet() bool <span class="cov0" title="0">{
        return rr.Get != nil
}</span>

// IsSend check if client want send information
func (rr *RoomRequest) IsSend() bool <span class="cov0" title="0">{
        return rr.Send != nil
}</span>

// RoomSend is struct of information, that client can send to room
type RoomSend struct {
        Cell   *Cell `json:"cell,omitempty"`
        Action *int  `json:"action,omitempty"`
}

// RoomGet is struct of flags, that client can get from room
type RoomGet struct {
        Players   bool `json:"players"`
        Observers bool `json:"observers"`
        Field     bool `json:"field"`
        History   bool `json:"history"`
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package game

import (
        "fmt"

        "github.com/go-park-mail-ru/2019_1_Escapade/internal/models"
        re "github.com/go-park-mail-ru/2019_1_Escapade/internal/return_errors"
)

// Save save room information to database
func (room *Room) Save() (err error) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return re.ErrorRoomDone()
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">players := room.players()
        game := models.Game{
                RoomID:        room.ID,
                Name:          room.Name,
                Status:        room.Status,
                Players:       len(players),
                TimeToPrepare: room.Settings.TimeToPrepare,
                TimeToPlay:    room.Settings.TimeToPlay,
                Date:          room.Date,
        }

        idWin := room.Winner()
        gamers := make([]models.Gamer, 0)
        for id, player := range players </span><span class="cov0" title="0">{
                gamer := models.Gamer{
                        ID:        player.ID,
                        Score:     player.Points,
                        Explosion: player.Died,
                        Won:       idWin == id,
                }
                gamers = append(gamers, gamer)
        }</span>

        <span class="cov0" title="0">field := models.Field{
                Width:     room.Field.Width,
                Height:    room.Field.Height,
                CellsLeft: room.Field.CellsLeft,
                Difficult: 0,
                Mines:     room.Field.Mines,
        }

        cells := make([]models.Cell, 0)
        for _, cellHistory := range room.Field.History </span><span class="cov0" title="0">{
                cell := models.Cell{
                        PlayerID: cellHistory.PlayerID,
                        X:        cellHistory.X,
                        Y:        cellHistory.Y,
                        Value:    cellHistory.Value,
                        Date:     cellHistory.Time,
                }
                cells = append(cells, cell)
        }</span>

        <span class="cov0" title="0">history := room.history()
        actions := make([]models.Action, 0)
        for _, actionHistory := range history </span><span class="cov0" title="0">{
                action := models.Action{
                        PlayerID: actionHistory.Player,
                        ActionID: actionHistory.Action,
                        Date:     actionHistory.Time,
                }
                actions = append(actions, action)
        }</span>

        <span class="cov0" title="0">gameInformation := models.GameInformation{
                Game:    game,
                Gamers:  gamers,
                Field:   field,
                Actions: actions,
                Cells:   cells,
        }

        fmt.Println("gameInformation:", gameInformation)

        if err = room.lobby.db.SaveGame(gameInformation); err != nil </span><span class="cov0" title="0">{
                fmt.Println("err. Cant save.", err.Error())
        }</span>

        <span class="cov0" title="0">var room1 *Room
        if room1, err = lobby.Load(room.ID); err != nil </span><span class="cov0" title="0">{
                fmt.Println("err. Cant load.", err.Error())
        }</span> else<span class="cov0" title="0"> {
                room1.debug()
        }</span>

        <span class="cov0" title="0">return</span>
}

// Load load room information from database
func (lobby *Lobby) Load(id string) (room *Room, err error) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return nil, re.ErrorLobbyDone()
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">var info models.GameInformation
        if info, err = lobby.db.GetGame(id); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // settings
        <span class="cov0" title="0">settings := &amp;models.RoomSettings{
                ID:            info.Game.RoomID,
                Name:          info.Game.Name,
                Width:         info.Field.Width,
                Height:        info.Field.Height,
                Players:       info.Game.Players,
                Observers:     1,
                TimeToPrepare: info.Game.TimeToPrepare,
                TimeToPlay:    info.Game.TimeToPlay,
        }

        if room, err = NewRoom(settings, id, lobby); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // main info
        <span class="cov0" title="0">room.ID = info.Game.RoomID
        room.Name = info.Game.Name
        room.Status = info.Game.Status
        room.setKilled(info.Game.Players)
        room.Date = info.Game.Date

        // actions
        for _, actionDB := range info.Actions </span><span class="cov0" title="0">{
                action := &amp;PlayerAction{
                        Player: actionDB.PlayerID,
                        Action: actionDB.ActionID,
                        Time:   actionDB.Date,
                }
                room.setToHistory(action)
        }</span>

        // field
        <span class="cov0" title="0">room.Field.Width = info.Field.Width
        room.Field.Height = info.Field.Height
        room.Field.CellsLeft = info.Field.CellsLeft
        room.Field.Mines = info.Field.Mines

        // cells
        room.Field.History = make([]Cell, 0)
        for _, cellDB := range info.Cells </span><span class="cov0" title="0">{
                cell := Cell{
                        X:        cellDB.X,
                        Y:        cellDB.Y,
                        Value:    cellDB.Value,
                        PlayerID: cellDB.PlayerID,
                        Time:     cellDB.Date,
                }
                room.Field.History = append(room.Field.History, cell)
        }</span>

        // players
        <span class="cov0" title="0">room._Players = newOnlinePlayers(info.Game.Players, *room.Field)
        for i, gamer := range info.Gamers </span><span class="cov0" title="0">{
                room._Players.Players[i] = Player{
                        ID:       gamer.ID,
                        Points:   gamer.Score,
                        Died:     gamer.Explosion,
                        Finished: true,
                }
        }</span>

        <span class="cov0" title="0">room._Messages, err = room.lobby.db.LoadMessages(true, info.Game.RoomID)

        return</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package game

import (
        "fmt"

        "github.com/go-park-mail-ru/2019_1_Escapade/internal/models"
        re "github.com/go-park-mail-ru/2019_1_Escapade/internal/return_errors"
)

// Winner determine who won the game
func (room *Room) Winner() (idWin int) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">max := 0

        players := room.players()
        for id, player := range players </span><span class="cov0" title="0">{
                if player.Points &gt; max </span><span class="cov0" title="0">{
                        max = player.Points
                        idWin = id
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// flagFound is called, when somebody find cell flag
func (room *Room) FlagFound(founder Connection, found *Cell) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">thatID := found.Value - CellIncrement
        if thatID == founder.ID() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">go room.IncreasePlayerPoints(founder.Index(), 1000)
        connections := room.playersConnections()
        for _, conn := range connections </span><span class="cov0" title="0">{
                fmt.Println("compare:", thatID, conn.ID())
                if thatID == conn.ID() </span><span class="cov0" title="0">{
                        go room.Kill(conn, ActionFlagLost)
                        return
                }</span>
        }
}

// isAlive check if connection is player and he is not died
func (room *Room) isAlive(conn *Connection) bool <span class="cov0" title="0">{
        index := conn.Index()
        return index &gt;= 0 &amp;&amp; !room.playerFinished(index)
}</span>

// kill make user die and check for finish battle
func (room *Room) Kill(conn *Connection, action int) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        // cause all in pointers
        <span class="cov0" title="0">if room.Status != StatusRunning </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if room.isAlive(conn) </span><span class="cov0" title="0">{
                room.SetFinished(conn)

                cell := room.playerFlag(conn.Index())
                room.Field.SetCellFlagTaken(&amp;cell)

                if room.playersCapacity() &lt;= room.killed()+1 </span><span class="cov0" title="0">{
                        room.FinishGame(false)
                }</span>
                <span class="cov0" title="0">pa := *room.addAction(conn.ID(), action)
                go room.sendAction(pa, room.All)</span>
        }
        <span class="cov0" title="0">return</span>
}

// GiveUp kill connection, that call it
func (room *Room) GiveUp(conn *Connection) <span class="cov0" title="0">{
        room.Kill(conn, ActionGiveUp)
}</span>

// flagExists find players with such flag. This - flag owner
func (room *Room) flagExists(cell Cell, this *Connection) (found bool, conn Connection) <span class="cov0" title="0">{
        var player int
        flags := room.playersFlags()
        for index, flag := range flags </span><span class="cov0" title="0">{
                if (flag.X == cell.X) &amp;&amp; (flag.Y == cell.Y) </span><span class="cov0" title="0">{
                        if this == nil || index != this.Index() </span><span class="cov0" title="0">{
                                found = true
                                player = index
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">connections := room.playersConnections()
        for _, connection := range connections </span><span class="cov0" title="0">{
                if connection.Index() == player </span><span class="cov0" title="0">{
                        conn = *connection
                        break</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func (room *Room) SetAndSendNewCell(conn Connection) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">found := true
        // create until it become unique
        var cell Cell
        for found </span><span class="cov0" title="0">{
                cell = room.Field.CreateRandomFlag(conn.ID())
                found, _ = room.flagExists(cell, nil)
        }</span>
        <span class="cov0" title="0">go room.SetFlagCoordinates(conn, cell)
        response := models.RandomFlagSet(cell)
        conn.SendInformation(response)</span>
}

// setFlag handle user wanna set flag
func (room *Room) SetFlag(conn *Connection, cell *Cell) bool <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        // if user try set flag after game launch
        <span class="cov0" title="0">if room.Status != StatusFlagPlacing </span><span class="cov0" title="0">{
                response := models.FailFlagSet(cell, re.ErrorBattleAlreadyBegan())
                conn.SendInformation(response)
                return false
        }</span>

        <span class="cov0" title="0">if !room.Field.IsInside(cell) </span><span class="cov0" title="0">{
                response := models.FailFlagSet(cell, re.ErrorCellOutside())
                conn.SendInformation(response)
                return false
        }</span>

        <span class="cov0" title="0">if !room.isAlive(conn) </span><span class="cov0" title="0">{
                response := models.FailFlagSet(cell, re.ErrorPlayerFinished())
                conn.SendInformation(response)
                return false
        }</span>

        <span class="cov0" title="0">if found, prevConn := room.flagExists(*cell, conn); found </span><span class="cov0" title="0">{
                go room.SetAndSendNewCell(*conn)
                go room.SetAndSendNewCell(prevConn)
                return true
        }</span>

        <span class="cov0" title="0">go room.SetFlagCoordinates(*conn, *cell)
        return true</span>
}

// setFlags set players flags to field
// call it if game has already begun
func (room *Room) setFlags() <span class="cov0" title="0">{
        flags := room.playersFlags()
        for _, cell := range flags </span><span class="cov0" title="0">{
                room.Field.SetFlag(&amp;cell)
        }</span>
}

// fillField set flags and mines
func (room *Room) FillField() <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">fmt.Println("fillField", room.Field.Height, room.Field.Width, len(room.Field.Matrix))

        room.setFlags()
        room.Field.SetMines()</span>

}

func (room *Room) addAction(id int, action int) (pa *PlayerAction) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">pa = NewPlayerAction(id, action)
        room.setToHistory(pa)
        return</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package game

import (
        "github.com/go-park-mail-ru/2019_1_Escapade/internal/metrics"
        "github.com/go-park-mail-ru/2019_1_Escapade/internal/utils"

        "fmt"
        "time"
)

// Enter handle user joining as player or observer
func (room *Room) Enter(conn *Connection) bool <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">var done bool

        // if room is searching new players
        if room.Status == StatusPeopleFinding </span><span class="cov0" title="0">{
                conn.debug("You will be player!")
                if room.addPlayer(conn) </span><span class="cov0" title="0">{
                        done = true
                }</span>
        } else<span class="cov0" title="0"> if room.addObserver(conn) </span><span class="cov0" title="0">{
                conn.debug("You will be observer!")
                done = true
        }</span>
        <span class="cov0" title="0">return done</span>
}

// Free clear all resources. Call it when no
//  observers and players inside
func (room *Room) Free() <span class="cov0" title="0">{

        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.setDone()

        room.wGroup.Wait()

        room.Status = StatusFinished
        go room.historyFree()
        go room.messagesFree()
        go room.playersFree()
        go room.observersFree()
        go room.Field.Free()

        close(room.chanFinish)</span>
}

// Close drives away players out of the room, free resources
// and inform lobby, that rooms closes
func (room *Room) Close() bool <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">fmt.Println("Can close?", room.lobby.canCloseRooms)
        if !room.lobby.canCloseRooms </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">fmt.Println("We closed room :С")
        room.LeaveAll()
        room.lobby.CloseRoom(room)
        fmt.Println("Prepare to free!")
        go room.Free()
        fmt.Println("We did it")
        return true</span>
}

// LeaveAll make every room connection to leave
func (room *Room) LeaveAll() <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">players := room.playersConnections()
        for _, conn := range players </span><span class="cov0" title="0">{
                go room.Leave(conn, ActionDisconnect)
        }</span>
        <span class="cov0" title="0">observers := room.observers()
        for _, conn := range observers </span><span class="cov0" title="0">{
                go room.Leave(conn, ActionDisconnect)
        }</span>
}

// Leave handle user going back to lobby
func (room *Room) Leave(conn *Connection, action int) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">metrics.Players.WithLabelValues(room.ID, conn.User.Name).Desc()
        go room.RemoveFromGame(conn, action == ActionDisconnect)

        pa := *room.addAction(conn.ID(), action)
        room.sendAction(pa, room.AllExceptThat(conn))
        fmt.Println("Left room")</span>
}

// openCell open cell
func (room *Room) OpenCell(conn *Connection, cell *Cell) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        // if user try set open cell before game launch
        <span class="cov0" title="0">if room.Status != StatusRunning </span><span class="cov0" title="0">{
                return
        }</span>

        // if wrong cell
        <span class="cov0" title="0">if !room.Field.IsInside(cell) </span><span class="cov0" title="0">{
                return
        }</span>

        // if user died
        <span class="cov0" title="0">if !room.isAlive(conn) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">index := conn.Index()

        // set who try open cell(for history)
        cell.PlayerID = conn.ID()
        cells := room.Field.OpenCell(cell)
        fmt.Println("len cell", len(cells))
        if len(cells) == 1 </span><span class="cov0" title="0">{
                newCell := cells[0]
                fmt.Println("newCell value", newCell.Value)
                if newCell.Value &lt; CellMine </span><span class="cov0" title="0">{
                        room.IncreasePlayerPoints(index, 1+newCell.Value)
                }</span> else<span class="cov0" title="0"> if newCell.Value == CellMine </span><span class="cov0" title="0">{
                        go room.IncreasePlayerPoints(index, -100) // в конфиг
                        room.Kill(conn, ActionExplode)
                }</span> else<span class="cov0" title="0"> if newCell.Value &gt;= CellIncrement </span><span class="cov0" title="0">{
                        room.FlagFound(*conn, &amp;newCell)
                }</span> else<span class="cov0" title="0"> if newCell.Value == CellOpened </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                for _, foundCell := range cells </span><span class="cov0" title="0">{
                        value := foundCell.Value
                        if value &lt; CellMine </span><span class="cov0" title="0">{
                                go room.IncreasePlayerPoints(index, 1+value)
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(cells) &gt; 0 </span><span class="cov0" title="0">{
                go room.sendPlayerPoints(room.player(index), room.All)
                go room.sendNewCells(cells, room.All)
        }</span>
        <span class="cov0" title="0">if room.Field.IsCleared() </span><span class="cov0" title="0">{
                go room.FinishGame(false)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (room *Room) CellHandle(conn *Connection, cell *Cell) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">fmt.Println("cellHandle")
        if room.Status == StatusFlagPlacing </span><span class="cov0" title="0">{
                room.SetFlag(conn, cell)
        }</span> else<span class="cov0" title="0"> if room.Status == StatusRunning </span><span class="cov0" title="0">{
                room.OpenCell(conn, cell)
        }</span>
        <span class="cov0" title="0">return</span>
}

// IsActive check if game is started and results not known
func (room *Room) IsActive() bool <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()
        <span class="cov0" title="0">return room.Status == StatusFlagPlacing || room.Status == StatusRunning</span>
}

func (room *Room) ActionHandle(conn *Connection, action int) (done bool) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">if room.IsActive() </span><span class="cov0" title="0">{
                if action == ActionGiveUp </span><span class="cov0" title="0">{
                        conn.debug("we see you wanna give up?")
                        go room.GiveUp(conn)
                        return true
                }</span>
        }
        <span class="cov0" title="0">if action == ActionBackToLobby </span><span class="cov0" title="0">{
                conn.debug("we see you wanna back to lobby?")
                go room.lobby.LeaveRoom(conn, room, ActionBackToLobby)
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// handleRequest
func (room *Room) HandleRequest(conn *Connection, rr *RoomRequest) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">if room == nil || room.Status == StatusFinished </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">conn.debug("room handle conn")
        if rr.IsGet() </span><span class="cov0" title="0">{
                go room.greet(conn)
        }</span> else<span class="cov0" title="0"> if rr.IsSend() </span><span class="cov0" title="0">{
                //done := false
                if rr.Send.Cell != nil </span><span class="cov0" title="0">{
                        if room.isAlive(conn) </span><span class="cov0" title="0">{
                                go room.CellHandle(conn, rr.Send.Cell)
                        }</span>
                } else<span class="cov0" title="0"> if rr.Send.Action != nil </span><span class="cov0" title="0">{
                        go room.ActionHandle(conn, *rr.Send.Action)
                }</span>
                //if done {
                //room.finishGame(true)
                //}
        } else<span class="cov0" title="0"> if rr.Message != nil </span><span class="cov0" title="0">{
                Message(lobby, conn, rr.Message, room.setToMessages,
                        room.send, room.InGame, true, room.ID)
        }</span>
}

func (room *Room) StartFlagPlacing() <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">fmt.Println("StartFlagPlacing")

        room.Status = StatusFlagPlacing
        players := room.playersConnections()
        for _, conn := range players </span><span class="cov0" title="0">{
                room.MakePlayer(conn)
        }</span>
        <span class="cov0" title="0">observers := room.observers()
        for _, conn := range observers </span><span class="cov0" title="0">{
                room.MakeObserver(conn)
        }</span>
        <span class="cov0" title="0">room.playersInit()

        go room.lobby.RoomStart(room)
        go room.run()

        go room.sendStatus(room.All)
        go room.sendField(room.All)
        go room.sendMessage("Battle will be start soon! Set your flag!", room.All)</span>
}

func (room *Room) StartGame() <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">room.Status = StatusRunning
        go room.sendStatus(room.All)
        go room.sendMessage("Battle began! Destroy your enemy!", room.All)
        room.FillField()</span>
}

func (room *Room) FinishGame(timer bool) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">if room.Status == StatusFinished </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !timer </span><span class="cov0" title="0">{
                room.chanFinish &lt;- struct{}{}
        }</span>
        <span class="cov0" title="0">fmt.Println(room.ID, "We finish room!", room.Status)

        room.Status = StatusFinished
        fmt.Println(room.ID, "We finish room?", room.Status)

        go room.sendStatus(room.All)
        go room.sendMessage("Battle finished!", room.All)
        go room.sendGameOver(timer, room.All)
        go room.Save()
        room.lobby.roomFinish(room)
        players := room.players()
        for _, player := range players </span><span class="cov0" title="0">{
                player.Finished = true
        }</span>
}

// initTimers launch game timers. Call it when flag placement starts
func (room *Room) initTimers() (prepare, play *time.Timer) <span class="cov0" title="0">{
        prepare = time.NewTimer(time.Second *
                time.Duration(room.Settings.TimeToPrepare))
        play = time.NewTimer(time.Second *
                time.Duration(room.Settings.TimeToPlay))
        return
}</span>

func (room *Room) run() <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                utils.CatchPanic("room_handle.go run()")
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">ticker := time.NewTicker(time.Second * 4)

        timerToPrepare, timerToPlay := room.initTimers()
        defer func() </span><span class="cov0" title="0">{
                ticker.Stop()
                timerToPrepare.Stop()
                timerToPlay.Stop()
                fmt.Println("Room: Game is over!")
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-room.chanFinish:<span class="cov0" title="0">
                        return</span>
                case &lt;-timerToPrepare.C:<span class="cov0" title="0">
                        go room.StartGame()</span>
                case &lt;-timerToPlay.C:<span class="cov0" title="0">
                        go room.FinishGame(false)
                        return</span>
                case clock := &lt;-ticker.C:<span class="cov0" title="0">
                        fmt.Println("clock!", room.ID)
                        go room.sendMessage(clock.String()+" passed", room.All)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package game

import (
        "time"

        "encoding/json"

        "github.com/go-park-mail-ru/2019_1_Escapade/internal/models"
)

// Room consist of players and observers, field and history
type RoomJSON struct {
        ID     string `json:"id"`
        Name   string `json:"name"`
        Status int    `json:"status"`

        Players   *OnlinePlayers    `json:"players"`
        Observers *Connections      `json:"observers,omitempty"`
        History   []*PlayerAction   `json:"history,omitempty"`
        Messages  []*models.Message `json:"messages"`

        Field    *Field               `json:"field,omitempty"`
        Date     time.Time            `json:"date,omitempty"`
        Settings *models.RoomSettings `json:"settings"`
}

func (room *Room) JSON() RoomJSON <span class="cov0" title="0">{
        return RoomJSON{
                ID:        room.ID,
                Name:      room.Name,
                Status:    room.Status,
                Players:   room._Players,
                Observers: room._Observers,
                History:   room.history(),
                Messages:  room._Messages,
                Field:     room.Field,
                Date:      room.Date,
                Settings:  room.Settings,
        }
}</span>

func (room *Room) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(room.JSON())
}</span>

func (room *Room) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        temp := &amp;RoomJSON{}

        if err := json.Unmarshal(b, &amp;temp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">room.Name = temp.Name
        room.Status = temp.Status
        room._Players = temp.Players
        room._Observers = temp.Observers
        room._History = temp.History
        room._Messages = temp.Messages
        room.Date = temp.Date
        room.Settings = temp.Settings

        return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package game

import "github.com/go-park-mail-ru/2019_1_Escapade/internal/models"

// setMatrixValue set a value to matrix
func (room *Room) setDone() <span class="cov0" title="0">{
        room.doneM.Lock()
        room._done = true
        room.doneM.Unlock()
}</span>

// getMatrixValue get a value from matrix
func (room *Room) done() bool <span class="cov0" title="0">{
        room.doneM.RLock()
        v := room._done
        room.doneM.RUnlock()
        return v
}</span>

// getMatrixValue get a value from matrix
func (room *Room) killed() int <span class="cov0" title="0">{
        room.killedM.RLock()
        v := room._killed
        room.killedM.RUnlock()
        return v
}</span>

// getMatrixValue get a value from matrix
func (room *Room) incrementKilled() <span class="cov0" title="0">{
        room.killedM.Lock()
        room._killed++
        room.killedM.Unlock()
}</span>

// getMatrixValue get a value from matrix
func (room *Room) setKilled(killed int) <span class="cov0" title="0">{
        room.killedM.Lock()
        room._killed = killed
        room.killedM.Unlock()
}</span>

// getMatrixValue get a value from matrix
func (room *Room) observers() (v []*Connection) <span class="cov0" title="0">{
        room.observersM.RLock()
        defer room.observersM.RUnlock()

        observers := room._Observers
        if observers == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">v = room._Observers.Get
        return</span>
}

// getMatrixValue get a value from matrix
func (room *Room) players() (v []Player) <span class="cov0" title="0">{
        room.playersM.RLock()
        defer room.playersM.RUnlock()

        players := room._Players
        if players == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">v = room._Players.Players
        return</span>
}

func (room *Room) SetFlagCoordinates(conn Connection, cell Cell) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">room.playersM.Lock()
        room._Players.Flags[conn.Index()].X = cell.X
        room._Players.Flags[conn.Index()].Y = cell.Y
        room.playersM.Unlock()</span>
}

// getMatrixValue get a value from matrix
func (room *Room) playersConnections() (v []*Connection) <span class="cov0" title="0">{
        room.playersM.RLock()
        defer room.playersM.RUnlock()

        if room._Players == nil || room._Players.Connections == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">v = room._Players.Connections
        return</span>
}

// getMatrixValue get a value from matrix
func (room *Room) playersFlags() (v []Cell) <span class="cov0" title="0">{
        room.playersM.RLock()
        defer room.playersM.RUnlock()

        if room._Players == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">v = room._Players.Flags
        return</span>
}

// getMatrixValue get a value from matrix
func (room *Room) playersCapacity() int <span class="cov0" title="0">{
        room.playersM.RLock()
        defer room.playersM.RUnlock()

        if room._Players == nil || room._Players.Connections == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">v := room._Players.Capacity
        return v</span>
}

// getMatrixValue get a value from matrix
func (room *Room) IncreasePlayerPoints(index, points int) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">room.playersM.Lock()
        defer room.playersM.Unlock()

        players := room._Players
        if players == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if index &gt;= len(room._Players.Players) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room._Players.Players[index].Points += points</span>
}

// getMatrixValue get a value from matrix
func (room *Room) playerFinished(index int) bool <span class="cov0" title="0">{

        room.playersM.RLock()
        defer room.playersM.RUnlock()

        players := room._Players
        if players == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if index &gt;= len(room._Players.Players) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">v := room._Players.Players[index].Finished
        return v</span>
}

// getMatrixValue get a value from matrix
func (room *Room) player(index int) (v Player) <span class="cov0" title="0">{

        room.playersM.RLock()
        defer room.playersM.RUnlock()

        players := room._Players
        if players == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if index &gt;= len(room._Players.Players) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">v = room._Players.Players[index]
        return v</span>
}

// getMatrixValue get a value from matrix
func (room *Room) playersInit() <span class="cov0" title="0">{

        room.playersM.Lock()
        defer room.playersM.Unlock()
        room._Players.Init(room.Field)
}</span>

// getMatrixValue get a value from matrix
func (room *Room) playerFlag(index int) (v Cell) <span class="cov0" title="0">{

        room.playersM.RLock()
        defer room.playersM.RUnlock()

        players := room._Players
        if players == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if index &gt;= len(room._Players.Players) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">v = room._Players.Flags[index]
        return v</span>
}

// SetFinished increment amount of killed
func (room *Room) SetFinished(conn *Connection) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">index := conn.Index()
        if index &lt; 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.playersM.Lock()
        room._Players.Players[index].Finished = true
        room._Players.Players[index].Died = true
        room.playersM.Unlock()

        room.killedM.Lock()
        room._killed++
        room.killedM.Unlock()</span>
}

// SetFinished increment amount of killed
func (room *Room) setCell(conn *Connection) (flag *Cell) <span class="cov0" title="0">{

        index := conn.Index()
        if index &lt; 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.playersM.Lock()
        room._Players.Flags[index].PlayerID = conn.ID()
        room._Players.Flags[index].Value = conn.ID() + CellIncrement
        flag = &amp;room._Players.Flags[index]
        room.playersM.Unlock()
        return</span>
}

// getMatrixValue get a value from matrix
func (room *Room) history() []*PlayerAction <span class="cov0" title="0">{
        room.historyM.RLock()
        v := room._History
        room.historyM.RUnlock()
        return v
}</span>

// getMatrixValue get a value from matrix
func (room *Room) setToHistory(action *PlayerAction) <span class="cov0" title="0">{
        room.historyM.Lock()
        defer room.historyM.Unlock()
        room._History = append(room._History, action)
}</span>

// getMatrixValue get a value from matrix
func (room *Room) setToMessages(message *models.Message) <span class="cov0" title="0">{
        room.messagesM.Lock()
        defer room.messagesM.Unlock()
        room._Messages = append(room._Messages, message)
}</span>

func (room *Room) historyFree() <span class="cov0" title="0">{
        room.historyM.Lock()
        room._History = nil
        room.historyM.Unlock()
}</span>

func (room *Room) messagesFree() <span class="cov0" title="0">{
        room.messagesM.Lock()
        room._Messages = nil
        room.messagesM.Unlock()
}</span>

func (room *Room) playersFree() <span class="cov0" title="0">{
        room.playersM.Lock()
        room._Players = nil
        room.playersM.Unlock()
}</span>

func (room *Room) observersFree() <span class="cov0" title="0">{
        room.observersM.Lock()
        room._Observers = nil
        room.observersM.Unlock()
}</span>

func (room *Room) observersEnoughPlace() bool <span class="cov0" title="0">{
        room.observersM.RLock()
        v := room._Observers.enoughPlace()
        room.observersM.RUnlock()
        return v
}</span>

func (room *Room) playersEnoughPlace() bool <span class="cov0" title="0">{
        room.playersM.RLock()
        v := room._Players.enoughPlace()
        room.playersM.RUnlock()
        return v
}</span>

// getMatrixValue get a value from matrix
func (room *Room) playersAdd(conn *Connection, kill bool) <span class="cov0" title="0">{

        room.playersM.Lock()
        defer room.playersM.Unlock()
        room._Players.Add(conn, kill)
}</span>

// getMatrixValue get a value from matrix
func (room *Room) observersAdd(conn *Connection, kill bool) <span class="cov0" title="0">{

        room.observersM.Lock()
        defer room.observersM.Unlock()
        room._Observers.Add(conn, kill)
}</span>

// getMatrixValue get a value from matrix
func (room *Room) playersRemove(conn *Connection) <span class="cov0" title="0">{

        room.playersM.Lock()
        defer room.playersM.Unlock()
        room._Players.Remove(conn)
}</span>

// getMatrixValue get a value from matrix
func (room *Room) observersRemove(conn *Connection) <span class="cov0" title="0">{

        room.observersM.Lock()
        defer room.observersM.Unlock()
        room._Observers.Remove(conn)
}</span>

// getMatrixValue get a value from matrix
func (room *Room) playersSearchIndexPlayer(conn *Connection) int <span class="cov0" title="0">{

        room.playersM.RLock()
        defer room.playersM.RUnlock()
        i := room._Players.SearchIndexPlayer(conn)
        return i
}</span>

// getMatrixValue get a value from matrix
func (room *Room) playersEmpty() bool <span class="cov0" title="0">{

        room.playersM.RLock()
        defer room.playersM.RUnlock()
        v := room._Players.Empty()
        return v
}</span>

// getMatrixValue get a value from matrix
func (room *Room) observersSearch(conn *Connection) int <span class="cov0" title="0">{

        room.playersM.RLock()
        defer room.playersM.RUnlock()
        i := room._Observers.Search(conn)
        return i
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package game

import (
        "fmt"

        "github.com/go-park-mail-ru/2019_1_Escapade/internal/metrics"
)

// RecoverPlayer call it in lobby.join if player disconnected
func (room *Room) RecoverPlayer(newConn *Connection) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        // add connection as player
        <span class="cov0" title="0">go room.MakePlayer(newConn)
        pa := *room.addAction(newConn.ID(), ActionReconnect)
        go room.sendAction(pa, room.AllExceptThat(newConn))
        go room.greet(newConn)

        return</span>
}

// RecoverObserver recover connection as observer
func (room *Room) RecoverObserver(oldConn *Connection, newConn *Connection) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">go room.MakeObserver(newConn)
        pa := *room.addAction(newConn.ID(), ActionReconnect)
        go room.sendAction(pa, room.AllExceptThat(newConn))
        go room.greet(newConn)

        return</span>
}

// observe try to connect user as observer
func (room *Room) addObserver(conn *Connection) bool <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">metrics.Players.WithLabelValues(room.ID, conn.User.Name).Inc()

        // if we havent a place
        if !room.observersEnoughPlace() </span><span class="cov0" title="0">{
                conn.debug("Room cant execute request ")
                return false
        }</span>
        <span class="cov0" title="0">conn.debug("addObserver")
        go room.MakeObserver(conn)

        go room.addAction(conn.ID(), ActionConnectAsObserver)
        go room.sendObserverEnter(*conn, room.AllExceptThat(conn))
        room.lobby.sendRoomUpdate(*room, All)

        return true</span>
}

// EnterPlayer handle player try to enter room
func (room *Room) addPlayer(conn *Connection) bool <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">metrics.Players.WithLabelValues(room.ID, conn.User.Name).Inc()

        // if room have already started
        // if room.Status != StatusPeopleFinding {
        //         return false
        // }

        conn.debug("Room(" + room.ID + ") wanna connect you")

        // if room hasnt got places
        if !room.playersEnoughPlace() </span><span class="cov0" title="0">{
                conn.debug("Room(" + room.ID + ") hasnt any place")
                return false
        }</span>

        <span class="cov0" title="0">room.MakePlayer(conn)

        go room.addAction(conn.ID(), ActionConnectAsPlayer)
        go room.sendPlayerEnter(*conn, room.AllExceptThat(conn))
        go room.lobby.sendRoomUpdate(*room, All)

        fmt.Println("len", room._Players.Connections)
        if !room.playersEnoughPlace() </span><span class="cov0" title="0">{
                room.StartFlagPlacing()
        }</span>

        <span class="cov0" title="0">return true</span>
}

// MakePlayer mark connection as connected as Player
// add to players slice and set flag inRoom true
func (room *Room) MakePlayer(conn *Connection) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">if room.Status != StatusPeopleFinding </span><span class="cov0" title="0">{
                room.lobby.waiterToPlayer(conn)
                conn.setBoth(false)
        }</span> else<span class="cov0" title="0"> {
                conn.setBoth(true)
        }</span>
        <span class="cov0" title="0">room.playersAdd(conn, false)
        room.greet(conn)
        conn.PushToRoom(room)</span>
}

// MakeObserver mark connection as connected as Observer
// add to observers slice and set flag inRoom true
func (room *Room) MakeObserver(conn *Connection) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">if room.Status != StatusPeopleFinding </span><span class="cov0" title="0">{
                room.lobby.waiterToPlayer(conn)
                conn.setBoth(false)
        }</span> else<span class="cov0" title="0"> {
                conn.setBoth(true)
        }</span>
        <span class="cov0" title="0">room.observersAdd(conn, false)
        go room.greet(conn)
        conn.PushToRoom(room)</span>
}

func (room *Room) RemoveFromGame(conn *Connection, disconnected bool) <span class="cov0" title="0">{
        if room.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">room.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                room.wGroup.Done()
        }</span>()

        <span class="cov0" title="0">fmt.Println("removeDuringGame")
        fmt.Println("removeDuringGame before len", len(room._Players.Connections))

        i := room.playersSearchIndexPlayer(conn)
        if i &gt;= 0 </span><span class="cov0" title="0">{
                if room.Status == StatusRunning &amp;&amp; !disconnected </span><span class="cov0" title="0">{
                        fmt.Println("give up", i)
                        room.GiveUp(conn)
                }</span>

                <span class="cov0" title="0">room.playersRemove(conn)
                go room.sendPlayerExit(*conn, room.All)</span>
        } else<span class="cov0" title="0"> {
                go room.sendObserverExit(*conn, room.All)
                room.observersRemove(conn)
        }</span>

        <span class="cov0" title="0">fmt.Println("removeDuringGame after len", len(room._Players.Connections))
        fmt.Println("removeDuringGame system says", room.playersEmpty())
        if room.playersEmpty() </span><span class="cov0" title="0">{
                fmt.Println("room.Players.Empty")
                room.Close()
        }</span>
        <span class="cov0" title="0">fmt.Println("there")</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package game

import (
        "github.com/go-park-mail-ru/2019_1_Escapade/internal/models"
        "github.com/go-park-mail-ru/2019_1_Escapade/internal/utils"
)

// sendToAllInRoom send info to those in room, whose predicate
// returns true
func (room *Room) send(info interface{}, predicate SendPredicate) <span class="cov0" title="0">{
        players := room.playersConnections()
        observers := room.observers()
        SendToConnections(info, predicate, players, observers)
}</span>

func (room *Room) sendMessage(text string, predicate SendPredicate) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("room_send.go sendMessage()")
        }</span>()

        <span class="cov0" title="0">room.send("Room("+room.ID+"):"+text, predicate)</span>
}

// sendTAIRPeople send players, observers and history to all in room
func (room *Room) sendPlayerPoints(player Player, predicate SendPredicate) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("room_send.go sendPlayerPoints()")
        }</span>()

        <span class="cov0" title="0">response := models.Response{
                Type:  "RoomPlayerPoints",
                Value: player,
        }
        room.send(response, predicate)</span>
}

// sendTAIRPeople send players, observers and history to all in room
func (room *Room) sendGameOver(timer bool, predicate SendPredicate) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("room_send.go sendGameOver()")
        }</span>()

        <span class="cov0" title="0">cells := make([]Cell, 0)
        room.Field.OpenEverything(&amp;cells)
        response := models.Response{
                Type: "RoomGameOver",
                Value: struct {
                        Players []Player `json:"players"`
                        Cells   []Cell   `json:"cells"`
                        Winner  int      `json:"winner"`
                        Timer   bool     `json:"timer"`
                }{
                        Players: room.players(),
                        Cells:   cells,
                        Winner:  room.Winner(),
                        Timer:   timer,
                },
        }
        room.send(response, predicate)</span>
}

func (room *Room) sendNewCells(cells []Cell, predicate SendPredicate) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("room_send.go RoomNewCells()")
        }</span>()

        <span class="cov0" title="0">response := models.Response{
                Type:  "RoomNewCells",
                Value: cells,
        }
        room.send(response, predicate)</span>
}

// sendTAIRPeople send players, observers and history to all in room
func (room *Room) sendPlayerEnter(conn Connection, predicate SendPredicate) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("room_send.go RoomPlayerEnter()")
        }</span>()

        <span class="cov0" title="0">response := models.Response{
                Type:  "RoomPlayerEnter",
                Value: conn,
        }
        room.send(response, predicate)</span>
}

// sendTAIRPeople send players, observers and history to all in room
func (room *Room) sendPlayerExit(conn Connection, predicate SendPredicate) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("room_send.go RoomPlayerExit()")
        }</span>()

        <span class="cov0" title="0">response := models.Response{
                Type:  "RoomPlayerExit",
                Value: conn,
        }
        room.send(response, predicate)</span>
}

// sendTAIRPeople send players, observers and history to all in room
func (room *Room) sendObserverEnter(conn Connection, predicate SendPredicate) <span class="cov0" title="0">{
        response := models.Response{
                Type:  "RoomObserverEnter",
                Value: conn,
        }
        room.send(response, predicate)
}</span>

// sendTAIRPeople send players, observers and history to all in room
func (room *Room) sendObserverExit(conn Connection, predicate SendPredicate) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("room_send.go RoomObserverExit()")
        }</span>()

        <span class="cov0" title="0">response := models.Response{
                Type:  "RoomObserverExit",
                Value: conn,
        }
        room.send(response, predicate)</span>
}

// sendTAIRPeople send players, observers and history to all in room
func (room *Room) sendStatus(predicate SendPredicate) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("room_send.go RoomStatus()")
        }</span>()

        <span class="cov0" title="0">response := models.Response{
                Type: "RoomStatus",
                Value: struct {
                        ID     string `json:"id"`
                        Status int    `json:"status"`
                }{
                        ID:     room.ID,
                        Status: room.Status,
                },
        }
        room.send(response, predicate)</span>
}

// sendTAIRHistory send actions history to all in room
func (room *Room) sendAction(pa PlayerAction, predicate SendPredicate) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("room_send.go sendAction()")
        }</span>()

        <span class="cov0" title="0">response := models.Response{
                Type:  "RoomAction",
                Value: pa,
        }
        room.send(response, predicate)</span>
}

// sendTAIRHistory send actions history to all in room
func (room *Room) sendError(err error, conn Connection) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("room_send.go sendError()")
        }</span>()

        <span class="cov0" title="0">response := models.Response{
                Type:  "RoomError",
                Value: err.Error(),
        }
        conn.SendInformation(response)</span>
}

// sendTAIRField send field to all in room
func (room *Room) sendField(predicate SendPredicate) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("room_send.go sendField()")
        }</span>()

        <span class="cov0" title="0">response := models.Response{
                Type:  "RoomField",
                Value: room.Field,
        }
        room.send(response, predicate)</span>
}

// sendTAIRAll send everything to one connection
func (room *Room) greet(conn *Connection) <span class="cov0" title="0">{
        if lobby.done() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lobby.wGroup.Add(1)
        defer func() </span><span class="cov0" title="0">{
                lobby.wGroup.Done()
                utils.CatchPanic("room_send.go greet()")
        }</span>()

        <span class="cov0" title="0">var flag Cell
        if conn.Index() &gt;= 0 </span><span class="cov0" title="0">{
                flag = *room.setCell(conn)
        }</span>

        <span class="cov0" title="0">copy := *conn

        response := models.Response{
                Type: "Room",
                Value: struct {
                        Room     *Room                 `json:"room"`
                        You      models.UserPublicInfo `json:"you"`
                        Observer bool                  `json:"observer"`
                        Flag     Cell                  `json:"flag,omitempty"`
                }{
                        Room:     room,
                        You:      *copy.User,
                        Observer: copy.Index() &lt; 0,
                        Flag:     flag,
                },
        }
        conn.SendInformation(response)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package game

import (
        "sync"
)

// SendPredicate - returns true if the parcel send to that conn
type SendPredicate func(conn *Connection) bool

// SendToConnections send 'info' to everybody,  whose predicate
// returns true
func SendToConnections(info interface{},
        predicate SendPredicate, groups ...[]*Connection) <span class="cov8" title="1">{

        waitJobs := &amp;sync.WaitGroup{}
        for _, group := range groups </span><span class="cov8" title="1">{
                for _, connection := range group </span><span class="cov0" title="0">{
                        if predicate(connection) </span><span class="cov0" title="0">{
                                waitJobs.Add(1)
                                go connection.sendGroupInformation(info, waitJobs)
                        }</span>
                }
        }
        <span class="cov8" title="1">waitJobs.Wait()</span>
}

// AllExceptThat is SendPredicate to SendToConnections
// it will send everybody except selected one and disconnected
func AllExceptThat(me *Connection) func(*Connection) bool <span class="cov8" title="1">{
        return func(conn *Connection) bool </span><span class="cov0" title="0">{
                return !conn.done() &amp;&amp; !me.done() &amp;&amp; conn != me &amp;&amp; conn.IsConnected()
        }</span>
}

// All is SendPredicate to SendToConnections
// it will send everybody, who is connected
func All(conn *Connection) bool <span class="cov0" title="0">{
        return !conn.done() &amp;&amp; conn.IsConnected()
}</span>

// All is SendPredicate to SendToConnections
// it will send everybody in room, who is connected
func (room *Room) All(conn *Connection) bool <span class="cov0" title="0">{
        return !conn.done() &amp;&amp; conn.Room() == room &amp;&amp; conn.IsConnected()
}</span>

// InGame is SendPredicate to SendToConnections
// it will send everybody in room, if game began
func (room *Room) InGame(conn *Connection) bool <span class="cov0" title="0">{
        return !conn.done() &amp;&amp; conn.Room() == room &amp;&amp; conn.IsConnected() &amp;&amp; !conn.Both()
}</span>

// AllExceptThat is SendPredicate to SendToConnections
// it will send everybody in room, except selected one
func (room *Room) AllExceptThat(me *Connection) func(*Connection) bool <span class="cov0" title="0">{
        return func(conn *Connection) bool </span><span class="cov0" title="0">{
                return !conn.done() &amp;&amp; !me.done() &amp;&amp; conn.Room() == room &amp;&amp; conn != me &amp;&amp; conn.IsConnected()
        }</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package game

import "fmt"

// OnlinePlayers online players
type OnlinePlayers struct {
        Capacity    int           `json:"capacity"`
        Players     []Player      `json:"players"`
        Flags       []Cell        `json:"flags"`
        Connections []*Connection `json:"connections"`
}

// Connections - slice of connections with capacity
type Connections struct {
        Capacity int           `json:"capacity"`
        Get      []*Connection `json:"get"`
}

// Rooms - slice of rooms with capacity
type Rooms struct {
        Capacity int     `json:"capacity"`
        Get      []*Room `json:"get"`
}

// NewConnections create instance of Connections
func newOnlinePlayers(size int, field Field) *OnlinePlayers <span class="cov8" title="1">{
        players := make([]Player, size)
        flags := field.RandomFlags(players)
        return &amp;OnlinePlayers{
                Capacity:    size,
                Players:     players,
                Flags:       flags,
                Connections: make([]*Connection, 0, size),
        }

}</span>

// Init create players and flags
func (onlinePlayers *OnlinePlayers) Init(field *Field) <span class="cov0" title="0">{

        for i, conn := range onlinePlayers.Connections </span><span class="cov0" title="0">{
                if i &gt; onlinePlayers.Capacity </span><span class="cov0" title="0">{
                        room := conn.Room()
                        if room == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">go room.Leave(conn, ActionBackToLobby)
                        continue</span>
                }
                <span class="cov0" title="0">onlinePlayers.Players[i] = *NewPlayer(conn.User.ID)
                conn.SetIndex(i)</span>
        }
        //onlinePlayers.Flags = field.RandomFlags(onlinePlayers.Players)

        <span class="cov0" title="0">return</span>
}

// NewConnections create instance of Connections
func NewConnections(capacity int) *Connections <span class="cov8" title="1">{
        return &amp;Connections{capacity,
                make([]*Connection, 0, capacity)}
}</span>

// NewRooms create instance of Rooms
func NewRooms(capacity int) *Rooms <span class="cov8" title="1">{
        return &amp;Rooms{capacity,
                make([]*Room, 0, capacity)}
}</span>

// search element in slice
func sliceIndex(limit int, predicate func(i int) bool) int <span class="cov8" title="1">{
        for i := 0; i &lt; limit; i++ </span><span class="cov0" title="0">{
                if predicate(i) </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// Free free memory
func (onlinePlayers *OnlinePlayers) Free() <span class="cov0" title="0">{

        if onlinePlayers == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; len(onlinePlayers.Connections); i++ </span><span class="cov0" title="0">{
                onlinePlayers.Connections[i] = nil
        }</span>

        <span class="cov0" title="0">onlinePlayers.Players = nil
        onlinePlayers.Flags = nil
        onlinePlayers.Connections = nil
        onlinePlayers = nil</span>
}

// SearchIndexPlayer search connection index in the slice of Players
func (onlinePlayers *OnlinePlayers) SearchIndexPlayer(conn *Connection) (i int) <span class="cov0" title="0">{
        return sliceIndex(onlinePlayers.Capacity, func(i int) bool </span><span class="cov0" title="0">{
                return onlinePlayers.Players[i].ID == conn.ID()
        }</span>)
}

// SearchConnection search connection index in the slice of connections
func (onlinePlayers *OnlinePlayers) SearchConnection(conn *Connection) (i int) <span class="cov0" title="0">{
        return sliceIndex(len(onlinePlayers.Connections), func(i int) bool </span><span class="cov0" title="0">{
                return onlinePlayers.Connections[i].ID() == conn.ID()
        }</span>)
}

// Free free memory
func (rooms *Rooms) Free() <span class="cov0" title="0">{
        if rooms == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for _, room := range rooms.Get </span><span class="cov0" title="0">{
                room.Free()
        }</span>
        <span class="cov0" title="0">rooms.Get = nil
        rooms.Capacity = 0
        rooms = nil</span>
}

// Free free memory
func (conns *Connections) Free() <span class="cov0" title="0">{
        if conns == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for _, conn := range conns.Get </span><span class="cov0" title="0">{
                conn.Free()
        }</span>
        <span class="cov0" title="0">conns.Get = nil
        conns.Capacity = 0</span>
}

// Empty check rooms length is 0
func (rooms *Rooms) Empty() bool <span class="cov0" title="0">{
        return len(rooms.Get) == 0
}</span>

// Empty check no connections connected
func (onlinePlayers *OnlinePlayers) Empty() bool <span class="cov0" title="0">{
        return len(onlinePlayers.Connections) == 0
}</span>

// Add try add element if its possible. Return bool result
// if element not exists it will be create, otherwise it will change its value
func (onlinePlayers *OnlinePlayers) Add(conn *Connection, kill bool) bool <span class="cov0" title="0">{
        var i int
        if i = onlinePlayers.SearchConnection(conn); i &gt;= 0 </span><span class="cov0" title="0">{
                oldConn := onlinePlayers.Connections[i]
                if kill &amp;&amp; !oldConn.Disconnected() </span><span class="cov0" title="0">{
                        oldConn.Kill("Another connection found", true)
                }</span>
                <span class="cov0" title="0">onlinePlayers.Connections[i] = conn
                i = oldConn.Index()</span>
        } else<span class="cov0" title="0"> if onlinePlayers.enoughPlace() </span><span class="cov0" title="0">{
                i = len(onlinePlayers.Connections)
                onlinePlayers.Connections = append(onlinePlayers.Connections, conn)
        }</span> else<span class="cov0" title="0"> {
                return false
        }</span>
        <span class="cov0" title="0">onlinePlayers.Players[i].ID = onlinePlayers.Connections[i].ID()
        onlinePlayers.Connections[i].SetIndex(i)
        return false</span>
}

// Remove delete element and decrement size if element
// exists in map
func (onlinePlayers *OnlinePlayers) Remove(conn *Connection) <span class="cov0" title="0">{
        size := len(onlinePlayers.Connections)
        i := onlinePlayers.SearchConnection(conn)
        if i &lt; 0 </span><span class="cov0" title="0">{
                fmt.Println("cant found", i, size)
                return
        }</span>
        <span class="cov0" title="0">onlinePlayers.Connections[i], onlinePlayers.Connections[size-1] = onlinePlayers.Connections[size-1], onlinePlayers.Connections[i]
        onlinePlayers.Connections[size-1] = nil
        onlinePlayers.Connections = onlinePlayers.Connections[:size-1]</span>
        //sendError(conn, "Remove", "You disconnected ")
}

// enoughPlace check that you can add more elements
func (onlinePlayers *OnlinePlayers) enoughPlace() bool <span class="cov0" title="0">{
        return len(onlinePlayers.Connections) &lt; onlinePlayers.Capacity
}</span>

// enoughPlace check that you can add more elements
func (rooms *Rooms) enoughPlace() bool <span class="cov0" title="0">{
        return len(rooms.Get) &lt; rooms.Capacity
}</span>

// SearchRoom find room with selected name and return it if success
// otherwise nil
func (rooms *Rooms) SearchRoom(id string) (i int, room *Room) <span class="cov0" title="0">{
        for i, room = range rooms.Get </span><span class="cov0" title="0">{
                if room.ID == id </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">i, room = -1, nil
        return</span>
}

// SearchPlayer find connection in rooms players and return it if success
// otherwise nil
func (rooms *Rooms) SearchPlayer(new *Connection) (int, *Room) <span class="cov0" title="0">{
        for _, room := range rooms.Get </span><span class="cov0" title="0">{
                i := room.playersSearchIndexPlayer(new)
                // cant found
                if i &lt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if room.playerFinished(i) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">return i, room</span>
        }
        <span class="cov0" title="0">return -1, nil</span>
}

// SearchObserver find connection in rooms obserers and return it if success
// otherwise nil
func (rooms *Rooms) SearchObserver(new *Connection) (old *Connection) <span class="cov0" title="0">{
        for _, room := range rooms.Get </span><span class="cov0" title="0">{
                i := room.observersSearch(new)
                if i &lt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">return room.observers()[i]</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Add try add element if its possible. Return bool result
// if element not exists it will be create, otherwise it will change its value
func (rooms *Rooms) Add(room *Room) bool <span class="cov0" title="0">{
        if i, _ := rooms.SearchRoom(room.ID); i &gt;= 0 </span><span class="cov0" title="0">{
                rooms.Get[i] = room
        }</span> else<span class="cov0" title="0"> if rooms.enoughPlace() </span><span class="cov0" title="0">{
                rooms.Get = append(rooms.Get, room)
        }</span> else<span class="cov0" title="0"> {
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// Remove delete element and decrement size if element
// exists in map
func (rooms *Rooms) Remove(room *Room) <span class="cov0" title="0">{
        size := len(rooms.Get)
        i, _ := rooms.SearchRoom(room.ID)
        if i &lt; 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">rooms.Get[i], rooms.Get[size-1] = rooms.Get[size-1], rooms.Get[i]
        rooms.Get[size-1] = nil
        rooms.Get = rooms.Get[:size-1]</span>
}

// CopyLast copy Last element of 'from' to that as slice
func (rooms *Rooms) CopyLast(from *Rooms) <span class="cov0" title="0">{
        rooms.Capacity = 1
        rooms.Get = from.Get[len(from.Get)-1:]
}</span>

////////////////// Connections //////////////////////

// CopyLast copy Last element of 'from' to that as slice
func (conns *Connections) CopyLast(from *Connections) <span class="cov0" title="0">{
        conns.Capacity = 1
        conns.Get = from.Get[len(from.Get)-1:]
}</span>

// Empty check rooms capacity is 0
// it will happen, when finish is over, cause
// when somebody explodes, the capacity decrements
func (conns *Connections) Empty() bool <span class="cov0" title="0">{
        return len(conns.Get) == 0
}</span>

// Search find connection in slice and return its index if success
// otherwise -1
func (conns *Connections) Search(conn *Connection) (i int) <span class="cov8" title="1">{
        return sliceIndex(len(conns.Get), func(i int) bool </span><span class="cov0" title="0">{ return conns.Get[i].ID() == conn.ID() }</span>)
}

// enoughPlace check that you can add more elements
func (conns *Connections) enoughPlace() bool <span class="cov8" title="1">{
        return len(conns.Get) &lt; conns.Capacity
}</span>

// Add try add element if its possible. Return bool result
// if element not exists it will be create, otherwise it will change its value
func (conns *Connections) Add(conn *Connection, kill bool) bool <span class="cov8" title="1">{
        if i := conns.Search(conn); i &gt;= 0 </span><span class="cov0" title="0">{
                oldConn := conns.Get[i]
                if kill &amp;&amp; !oldConn.Disconnected() </span><span class="cov0" title="0">{
                        oldConn.Kill("Another connection found", true)
                }</span>
                <span class="cov0" title="0">conns.Get[i] = conn</span>
        } else<span class="cov8" title="1"> if conns.enoughPlace() </span><span class="cov8" title="1">{
                conns.Get = append(conns.Get, conn)
        }</span> else<span class="cov0" title="0"> {
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// Remove delete element and decrement size if element
// exists in map
func (conns *Connections) Remove(conn *Connection) <span class="cov8" title="1">{
        i := conns.Search(conn)
        if i &lt; 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">size := len(conns.Get)
        conns.Get[i], conns.Get[size-1] = conns.Get[size-1], conns.Get[i]
        conns.Get[size-1] = nil
        conns.Get = conns.Get[:size-1]</span>
        //sendError(conn, "Remove", "You disconnected ")
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
