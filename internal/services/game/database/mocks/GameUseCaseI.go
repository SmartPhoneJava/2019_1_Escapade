// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import (
	config "github.com/go-park-mail-ru/2019_1_Escapade/internal/pkg/config"
	database "github.com/go-park-mail-ru/2019_1_Escapade/internal/services/game/database"

	mock "github.com/stretchr/testify/mock"

	models "github.com/go-park-mail-ru/2019_1_Escapade/internal/pkg/models"

	pkgdatabase "github.com/go-park-mail-ru/2019_1_Escapade/internal/pkg/database"
)

// GameUseCaseI is an autogenerated mock type for the GameUseCaseI type
type GameUseCaseI struct {
	mock.Mock
}

// Close provides a mock function with given fields:
func (_m *GameUseCaseI) Close() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Create provides a mock function with given fields: game
func (_m *GameUseCaseI) Create(game *models.Game) (int32, error) {
	ret := _m.Called(game)

	var r0 int32
	if rf, ok := ret.Get(0).(func(*models.Game) int32); ok {
		r0 = rf(game)
	} else {
		r0 = ret.Get(0).(int32)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*models.Game) error); ok {
		r1 = rf(game)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchAllGames provides a mock function with given fields: userID
func (_m *GameUseCaseI) FetchAllGames(userID int32) ([]models.GameInformation, error) {
	ret := _m.Called(userID)

	var r0 []models.GameInformation
	if rf, ok := ret.Get(0).(func(int32) []models.GameInformation); ok {
		r0 = rf(userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.GameInformation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int32) error); ok {
		r1 = rf(userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchAllRoomsID provides a mock function with given fields: userID
func (_m *GameUseCaseI) FetchAllRoomsID(userID int32) ([]string, error) {
	ret := _m.Called(userID)

	var r0 []string
	if rf, ok := ret.Get(0).(func(int32) []string); ok {
		r0 = rf(userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int32) error); ok {
		r1 = rf(userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchOneGame provides a mock function with given fields: roomID
func (_m *GameUseCaseI) FetchOneGame(roomID string) (models.GameInformation, error) {
	ret := _m.Called(roomID)

	var r0 models.GameInformation
	if rf, ok := ret.Get(0).(func(string) models.GameInformation); ok {
		r0 = rf(roomID)
	} else {
		r0 = ret.Get(0).(models.GameInformation)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(roomID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Get provides a mock function with given fields:
func (_m *GameUseCaseI) Get() pkgdatabase.Interface {
	ret := _m.Called()

	var r0 pkgdatabase.Interface
	if rf, ok := ret.Get(0).(func() pkgdatabase.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pkgdatabase.Interface)
		}
	}

	return r0
}

// Init provides a mock function with given fields: game
func (_m *GameUseCaseI) Init(game database.GameRepositoryI) database.GameUseCaseI {
	ret := _m.Called(game)

	var r0 database.GameUseCaseI
	if rf, ok := ret.Get(0).(func(database.GameRepositoryI) database.GameUseCaseI); ok {
		r0 = rf(game)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(database.GameUseCaseI)
		}
	}

	return r0
}

// Open provides a mock function with given fields: CDB, db
func (_m *GameUseCaseI) Open(CDB config.Database, db pkgdatabase.Interface) error {
	ret := _m.Called(CDB, db)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.Database, pkgdatabase.Interface) error); ok {
		r0 = rf(CDB, db)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Save provides a mock function with given fields: info
func (_m *GameUseCaseI) Save(info models.GameInformation) error {
	ret := _m.Called(info)

	var r0 error
	if rf, ok := ret.Get(0).(func(models.GameInformation) error); ok {
		r0 = rf(info)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Use provides a mock function with given fields: db
func (_m *GameUseCaseI) Use(db pkgdatabase.Interface) error {
	ret := _m.Called(db)

	var r0 error
	if rf, ok := ret.Get(0).(func(pkgdatabase.Interface) error); ok {
		r0 = rf(db)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
